/*
 * THIS SOURCE FILE IS PART OF JBASIC, AN OPEN SOURCE PUBLICLY AVAILABLE
 * JAVA SOFTWARE PACKAGE HOSTED BY SOURCEFORGE.NET
 * 
 * THIS SOFTWARE IS PROVIDED VIA THE GNU PUBLIC LICENSE AND IS FREELY
 * AVAILABLE FOR ANY PURPOSE COMMERCIAL OR OTHERWISE AS LONG AS THE AUTHORSHIP
 * AND COPYRIGHT INFORMATION IS RETAINED INTACT AND APPROPRIATELY VISIBLE
 * TO THE END USER.
 * 
 * SEE THE PROJECT FILE AT HTTP://WWW.SOURCEFORGE.NET/PROJECTS/JBASIC FOR
 * MORE INFORMATION.
 * 
 * COPYRIGHT 2003-2011 BY TOM COLE, TOMCOLE@USERS.SF.NET
 *
 */
package org.fernwood.jbasic.opcodes;

import org.fernwood.jbasic.JBasic;
import org.fernwood.jbasic.Status;
import org.fernwood.jbasic.compiler.Tokenizer;
import org.fernwood.jbasic.runtime.JBasicException;
import org.fernwood.jbasic.statements.Statement;
import org.fernwood.jbasic.value.Value;

/**
 * @author cole
 * 
 */
public class OpEXEC extends AbstractOpcode {

	/**
	 * Pop top string from stack, and execute it as a statement.
	 * @throws JBasicException  if a stack underflow occurs or there is
	 * an execution error with the resulting statement.
	 * 
	 * @see org.fernwood.jbasic.opcodes.AbstractOpcode#execute(org.fernwood.jbasic.opcodes.InstructionContext)
	 */
	public void execute(final InstructionContext env) throws JBasicException {

		String cmd = null;
		if (env.instruction.stringValid)
			cmd = env.instruction.stringOperand;
		else {
			cmd = env.pop().getString();
		}

		boolean fSandBox = false;
		if( env.instruction.integerValid && env.instruction.integerOperand >= 10)
			fSandBox = true;
		
		/*
		 * Create a statement object that will be used to process the text
		 * we get from the instruction argument or the stack.  Initialize
		 * it to look like a statement owned by the execution context of
		 * this bytecode.
		 */
		final Statement execStmt = new Statement(env.session, env.codeStream.debugger);
		execStmt.program = null  /* env.session.programs.getCurrent() */ ;
		execStmt.byteCode = null;
		execStmt.statementObject = null;
		if( env.codeStream.statement != null ) {
			execStmt.statementID = env.codeStream.statement.statementID;
			execStmt.fInDebugger = env.codeStream.statement.fInDebugger;
			execStmt.debugger = env.codeStream.statement.debugger;
		}
				
		/*
		 * Is there an ALIAS for this we need to use instead?  The
		 * store() operation normally handles these, but they don't
		 * have any effect on uncompilable code, so let's process the
		 * alias here instead, so it gets applied at the last moment
		 * in runtime, in case the SYS$ALIASES array has been updated.
		 * 
		 * Create a new temporary tokenizer to parse out the first item
		 * of the command.
		 */

		Tokenizer originalText = new Tokenizer(cmd, JBasic.compoundStatementSeparator);
		final String verb = originalText.nextToken().toUpperCase();

		/*
		 * If there is a record named SYS$ALIASES, use it to see if there
		 * is a substitution for the current verb.  If so, reconstruct the
		 * command line using the substitute verb and the rest of the old
		 * command line.
		 */
		final Value aliasRecord = env.session.globals().reference("SYS$ALIASES");
		if (aliasRecord != null && aliasRecord.isType(Value.RECORD)) {
				final Value sub = aliasRecord.getElement(verb);
				if (sub != null)
					cmd = sub.getString() + " " + originalText.getBuffer();
			}
		
		/*
		 * Attempt to store/compile the statement text we've been given
		 * and/or pieced together from aliases.
		 */
		execStmt.store(cmd);

		/*
		 * If it wasn't compilable, zap the byteCode. This prevents recursive
		 * attempts to _EXEC uncompilable code.
		 */
		if (execStmt.status.equals(Status.NOCOMPILE))
			execStmt.byteCode = null;

		boolean savedSandBox = false;
		if( fSandBox ) {
			savedSandBox = env.session.globals().localReference("SYS$SANDBOX").getBoolean();
			env.session.enableSandbox(fSandBox);
		}
		
		/*
		 * Execute the statement.  If it was compilable, then it will
		 * execute the generated bytecode.  If it was not compilable,
		 * an execute() method in a statement class will be located to
		 * run the statement interpretively.
		 */
		
		
		Status status = null;
		status = execStmt.execute(env.localSymbols, false);
		
		if( fSandBox )
			env.session.enableSandbox(savedSandBox);
		
		/*
		 * If we were told to capture the status rather than signal it,
		 * then get the SYS$STATUS value just set by the execute()
		 * method and leave it on the stack as the result.  Then reset
		 * the status of this statement to success so execution can 
		 * continue.
		 */
		if (env.instruction.integerValid && ((env.instruction.integerOperand % 10) == 1)) {
			env.push(env.localSymbols.reference("SYS$STATUS"));
			return;
		}

		if( !status.success())
			throw new JBasicException(status);
		
		if( status.equals("*STEP"))
			throw new JBasicException(status);
		
		return;
	}

}
