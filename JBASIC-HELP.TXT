..
THIS SOURCE FILE IS PART OF JBASIC, AN OPEN SOURCE PUBLICLY AVAILABLE
JAVA SOFTWARE PACKAGE HOSTED BY SOURCEFORGE.NET

THIS SOFTWARE IS PROVIDED VIA THE GNU PUBLIC LICENSE AND IS FREELY
AVAILABLE FOR ANY PURPOSE COMMERCIAL OR OTHERWISE AS LONG AS THE AUTHORSHIP
AND COPYRIGHT INFORMATION IS RETAINED INTACT AND APPROPRIATELY VISIBLE
TO THE END USER.

SEE THE PROJECT FILE AT HTTP://WWW.SOURCEFORGE.NET/PROJECTS/JBASIC FOR
MORE INFORMATION.
 
COPYRIGHT (C) 2003-2011 BY TOM COLE, TOMCOLE@USERS.SF.NET

Note that JBASIC uses TelnetD, an embedded Telnet daemon written 
in Java.  The copyright notice for this software is:

Java TelnetD library (embeddable telnet daemon)
Copyright (c) 2000-2005 Dieter Wimberger 
All rights reserved.
 

---------1---------2---------3---------4---------5---------6---------7---------8
12345678901234567890123456789012345678901234567890123456789012345678901234567890

JBasic online help file.  

This file contains the text used by the HELP command to display information
about topics on how to use JBasic or the syntax of the language statements
and use of runtime functions.

IF YOU ARE READING THIS TO LEARN HOW TO USE JBASIC, IT MAY BE EASIER TO USE
THE HELP COMMAND FROM WITHIN JBASIC.  ALSO SEE THE FILE "GETTING STARTED.TXT"
FOR THE SIMPLEST QUICK-START INSTRUCTIONS.

ALSO, THERE IS A PDF FILE WITH A USER'S GUIDE LOCATED ON THE JBASIC PROJECT
WEB PAGE AT SOURCEFORGE.  START AT

    http://sourceforge.net/projects/jbasic

AND FIND THE "DOWNLOAD FILES" AREA TO DOWNLOAD THE DOCUMENTATION OR THE MOST
RECENT VERSION OF THE PROJECT ITSELF, OR LOOK IN THE MOREDOC AREA OF THE 
ECLIPSE PROJECT TO FIND THE USER'S GUIDE PDF.   

In this file, each topic is introduced by a line with a "." to define the key
string that matches the text displayed.  Lines that begin with ".." create
a comment/documentation area that is skipped until the next "." topic.


.INTRODUCTION

JBasic, a Classic BASIC programming language, written in Java

JBasic is a programming environment for developing introductory skills,
though it can be used to create complex applications if needed.  It is
intended to be run interactively from a console-style environment.

  *  Type HELP PROGRAMS for a tutorial on how to enter and run
     programs. 
     
  *  Type HELP TOPICS for  a list of all available help topics.

  *  Type QUIT to exit from JBasic.

You can type HELP LEGAL NOTICES for copyright and licensing information.

.LEGAL NOTICES

* JBasic and "JBasic User's Guide" is Copyright (c) 2003-2010 Tom Cole.

* The Java TelnetD library is Copyright (c) 2000-2005 Dieter Wimberger. 

You can learn more about the licensing agreements and requirements, 
support, or project news for either JBasic or TelnetD by visiting 
their respective project sites on SourceForge:

	http://sourceforge.net/projects/jbasic
	
	http://sourceforge.net/projects/telnetd

.PROGRAMS
JBasic accepts commands at its console input prompt. These commands are
either executed immediately, or are compiled and stored away as programs
that can be run, modified, saved, and re-loaded.

JBasic programs reside in a "workspace", which is a collection of
programs that are available when a JBasic session is active.  When you
start JBasic, the default workspace is loaded.  If you change the
program(s) in the workspace, you can use the SAVE command to preserve
them so they will be available the next time you use JBasic.

JBasic has a "current program" which is the one that you are currently
adding statements to or executing.

Programs must have names, identified by the first statement, which is
a PROGRAM statement.  User programs usually have line numbers, used 
to organize the statements in the program. You can add statements to 
the current program by entering a line number (any positive integer 
greater than zero) followed by the text of a statement.  The statement
is compiled and stored away.  

    *    Use the NEW command to create a new program.
    
    *    Use the OLD command to access an existing program.
    
    *    Use the LIST command to see the current program.
    
    *    Use the RUN command to execute the current program.

Here is a simple program you can enter to get a feel for how JBasic
works.  Do this at the command line prompt, usually "BASIC>".

    BASIC> new hello
    BASIC> list

At this point, the program has one statement that was automatically
created for you, and some comments telling about the new program.
The output will look something like this:

     1000  PROGRAM HELLO
     1010  // Version: 1.0
     1020  // Date:    Fri Jan 28 14:17:38 EDT 2006
     1030  // Author:  cole
     1040  END

Add some more statements to the program.  You can enter these in any
order, since they are stored in the program in line-number order.  By
convention, program statement numbers typically being at 1000 and are
incremented by 10 to leave room for new statements.

    BASIC> 1035 print "Hello, world"
    BASIC> 1037 return

However, at this point we've got the new lines we entered starting 
at line number 1035, and the original lines created for us by the NEW
command starting at 1000.  Before we go further, let's neaten up the
program line numbering using the RENUMBER command.

    BASIC> renumber
    BASIC> list
    
   1000   PROGRAM HELLO
   1010   // Version: 1.0
   1020   // Date:    Fri Jan 28 14:17:38 EDT 2006
   1030   // Author:  cole
   1040   PRINT "Hello, world"
   1050   RETURN
   1060   END
       
Now let's run the stored program we have created.

    BASIC> run
    Hello, world
    BASIC>

You can type SAVE WORKSPACE now to store this workspace (which 
contains the program HELLO that you just wrote).  The next time
you run JBasic, it will reload the stored workspace and the 
HELLO program will be available for your use.

You can get a list of the programs that are available in your workspace
by typing SHOW PROGRAMS.  You will see any programs you have created,
plus a few that are built in to JBasic.  Program names with a "*"
after the name are ones that you have created or modified yourself.

It is possible to put more than one statement on a line by separating
them by with the colon (":") character.  When the statement is executed,
all statements on the line are executed unless they contain a GOTO
statement that transfers control.

   1040   X = 3 : Y = 5
   
When this statement is executed, both X and Y are set to the new values
3 and 5, respectively.
.LINE NUMBERS
JBasic programs that you type in at the console all have line numbers.
These line numbers are used to determine what order the statements are
stored in the active program.  Line numbers are all integer values
greater than zero.  Lower line numbers are stored and executed
before higher line numbers.

Before you can enter or edit a program, you must make it the "current
program."  This is done with the OLD or NEW commands - see the HELP
on those commands for more information. 

You enter programs statements just by typing the line number followed 
by the text of a statement.  For example,

    BASIC> new hello
    BASIC> 100 print "Hello, world"
    BASIC> 110 print "Bye for now."
    
Note that these two statements could be typed in any order, the line
numbers guarantee that the statements are stored in the correct order
in the program itself.

When you use NEW to create a new program, JBasic creates a program
with a few lines of text in it already.  For example, the above
operation would result in a complete program like the following.
[Note that the default line numbers may be different than shown
here.]

    BASIC> list
    
     1     PROGRAM HELLO
     2     // Version: 1.0
     3     // Date:    Sun Feb 05 13:27:22 EST 2006
     4     // Author:  tom
   100     PRINT "Hello, world"
   110     PRINT "Bye for now."
 
 JBasic automatically created lines 1-4 for you when you issued the
 NEW command.  (This behavior is controlled by the global variable
 SYS$AUTOCOMMENT; you can set it to false to disable the automatic
 generation of the comments).  By convention, the user starts entering 
 programs starting at line 100, and incrementing by 10 to make sure 
 there is room for additional statements.
 
 However, if you run out of room between two statements to type in new
 program statements, you can use the RENUMBER command, which renumbers
 the statements to make additional room for new statements.  For example,
 given the above program, we could use the RENUMBER command just to make
 the program slightly more readable:
 
 BASIC> renumber
 BASIC> list
   100      PROGRAM HELLO
   110      // Version: 1.0
   120      // Date:    Sun Feb 05 13:27:22 EST 2006
   130      // Author:  tom
   140      PRINT "Hello, world"
   150      PRINT "Bye for now."
   160      RETURN
 
 You can replace a line in a program just by typing the line number and
 a new statement to be stored in the same location in the program:
 
     150 print "Au revoir!"
     
 This replaces the line in the program with line number 150 with the
 new statement text.  You can delete a line in a program by typing
 the line number without putting any text after it.  To delete line
 150 entirely, just type:
 
 
   BASIC> 150
   BASIC> list
   100      PROGRAM HELLO
   110      // Version: 1.0
   120      // Date:    Sun Feb 05 13:27:22 EST 2006
   130      // Author:  tom
   140      PRINT "Hello, world"
   160      RETURN

You can use the DELETE command to delete all the lines in a program,
or a range of lines.

    BASIC> DELETE 110-130

In the sample program we're working on, this would delete the comment
lines that were automatically put in the program by the NEW command.

.WORKSPACE
A workspace is a collection of programs that are all loaded into the
running JBasic application, and can be executed with RUN, CALL, or
other statements that run stored programs, verbs, or functions.

All the programs in a workspace are available at the same time; you
don't need to specifically load and save individual programs.  Any
change you make to a program (such as discussed in the HELP section
on LINE NUMBERS) are immediately reflected in the program currently
in memory.

A workspace can be saved to disk.  This means that all the programs
in the workspace that you have written are stored into a single file
on the disk.  The default name for this file is "Workspace.jbasic"
in your home directory.  You save the current program(s) to disk
using the SAVE WORKSPACE command.

When JBasic starts up, it will load "Workspace.jbasic" if it is
found, so the programs you previously saved are available for your
use.  You can use the LOAD command to load additional programs
from saved workspaces, which are added to the current workspace.
If you are connecting to a multiuser JBasic server, your workspace
file is loaded from a location defined by the server administrator.

When you issue a SHOW PROGRAMS, SHOW VERBS, or SHOW FUNCTIONS
command, you see a list of all the programs of the requested
type.  If the program is one that you created (as opposed to being
built-in to JBasic), it will have an asterisk ("*") character
next to the name.  If you have changed the program since the
last time you started JBasic or saved the workspace, it will
have a sharp ("#") character, telling you that you will need to
SAVE the workspace to keep the changes you made.

Both the SAVE WORKSPACE and LOAD commands allow you to specify 
a different workspace name than the default, if you wish to 
create more than one workspace.  You might do this to maintain 
separate versions of your program, or to group programs by 
projects or other related activity.
.ADD
The ADD statement adds an expression to an existing variable.

    ADD 3.5 TO X

This calculates the value of X + 3.5 and stores the result
back into the variable X, which must already exist.  This is
semantically identical to LET X = X + 3.5.

This can also be used to add rows to a table.

    TABLE EMPLOYEES AS INTEGER ID, STRING NAME
    ADD [101, "Tom"] TO EMPLOYEES
    ADD [102, "Sue"] TO EMPLOYEES
    
.ARRAYS
An array is a list of values.  The values can be of any type - they
can be numbers, strings, or even other arrays.  In some cases the
array can be referenced just by name (such as when assigning it to
another variable).  You can also reference the individual elements
of the array using an array subscript notation:

    X = MY_DATA[3]
    
This references the third item in the MY_DATA list of values; the
value in that array element is assigned to the variable X.  You can
store items in an array the same way:

    MY_NAMES[5] = "Tony"

If the variable MY_NAMES is not already an array, the previous value
is discarded and the variable is re-typed as an array. If you store
an array element at a position that does not exist, the array is
automatically extended by adding array elements containing the
number zero.

You can find out how many elements are in the array by using the
length function, as in:

    N = LENGTH( MY_NAMES )

Note that you use the name of the array here, to return the value
5 if there are five elements in the array. If you had used the
expression LENGTH(MY_NAMES[5]), then you would instead get the
length of the fifth element in the array.

If you print an array element, it prints just like any other
scalar value.  You can also print the entire array, as in:

    X[1] = "Tom"
    X[2] = "Sue"
    PRINT X
    
The output is [ "Tom", "Sue" ], which shows an array (defined by
the brackets) with two items, each of which is a string. You can
create array constants like this yourself, as in

    PERSON = [ "Tom", 35 ]

This creates an array called PERSON with two elements.  The first
element is PERSON[1] and is a string "Tom". The second element is
PERSON[2] and is the number 35.

You can use arrays in the addition "+" operation if the first item
is an array.  The second item is added to the array by making a new
entry in the array.  If the second item is also an array, all the
elements of the second array are added to the end of the first array.
For example,

    X = [ 3, 5 ]
    Y = [ "Tom", 35 ]
    Z = X + Y
    Q = X + 22
    
In this case, Z will be [ 3, 5, "Tom", 35 ].  The value of Q will 
be [ 3, 5, 22 ].

You can specify a portion of an existing array using range notation,
which is the starting and ending indexes in the array separated by
the ".." range operator. For example, if the array X contains the
array [101, 122, 325, 403, 578] then the expression X[2..4] is the
sub-array [122, 325, 403].  Any expressions can be used in the
range values.

You can also specify a subset of an array using a selector array
which contains integer values that describe the indexes used to
select array elements that are moved to the result.  For example,

    X = ["Tom", "Sue", "Bob", "Mary"]
    Y = [1, 3]
    Z = X[Y]

The result of Z is ["Tom", "Bob"] since those are the elements
selected in the integer array (elements one and three).  Similarly,
you can use an indicator array that chooses elements based on the
boolean value of the array element:

    X = ["Tom", "Sue", "Bob", "Mary"]
    Y = [ false, true, false, true ]
    Z = X[Y]

The result is ["Sue", "Mary"] because the corresponding elements
of the array of boolean values contained true values.  The length
of the indicator array must match the length of the source array
in this case.
.BOOLEAN
The BOOLEAN statement is used to declare one or more variables of
type BOOLEAN, and optionally give them an initial value.

	BOOLEAN var1 [= value1][, var2[=value2]...]

The verb is followed by one or or more variable names separated by
commas.  Any of the variables may optionally be followed by a value
expression, which is automatically converted to a BOOLEAN data type
before being stored in the variable.
.BREAK
The BREAK command is used to control breakpoints in the debugger.
See the HELP on DEBUGGER to get more information on how to run a
program under control of the debugger.  The BREAK command can
only be used when the debugger is active.

The BREAK command has several formats, each of which are described
here.

    BREAK AT line-number

This specifies a breakpoint at a given line number in the program.
When this line is about to be executed, the debugger will gain
control of the running program and let you execute new debugger
commands.  The breakpoint is triggered each time the given line
is executed.

    BREAK WHEN expression

This causes a breakpoint when the expression evaluates to TRUE.
When it becomes true the first time, then a breakpoint is set and
the debugger lets you enter debug commands.  The breakpoint will
not be hit again until the expression goes from false to true.
So a break point set using BREAK WHEN I=5 will halt execution at
the moment when I becomes equal to 5, but won't halt execution
continually as long as I is still 5.  It will only break when 
I becomes 5 the next time.

    BREAK LIST

Each breakpoint is given a name when it is created, in the form
BREAK_n where "n" is a sequence number.  You can see a list of
the breakpoints you have specified and their name using the 
BREAK LIST command.  This list is useful for the BREAK CLEAR
command.

    BREAK CLEAR name
    BREAK CLEAR ALL

This lets you clear (remove) a specific breakpoint by name 
(usually determined by the BREAK LIST command) or to remove
all breakpoints.

.CALL
The CALL statement executes another program (optionally passing in
arguments to it) and then resumes execution of the current program.

    CALL name [ ( arg1 [, arg2...)] [RETURNS variable]
    
The name of the program is usually an identifier that is the name of
the PROGRAM that you are calling.  It can also be written as

    CALL USING( expression ) ...

In this case, the expression is evaluated, and the result is treated
as the name of the program to call.  This allows you to put the name
of the program in a variable and use that variable to indicate which
program to call.

If there are arguments to pass to the program, they are given in
parenthesis after the program name.  The number of arguments must be
compatible with the number of arguments that the calling program
expects.   See the help on PROGRAM for more information about how
arguments are declared, optionally given default values, and stored
in local variables in the CALLed program.

A called program can return a value to the calling program,
using the RETURNS statement.  In this case, the return value will be 
stored in the RETURNS variable.  This is the name of a variable such
as you would use in an assignment (LET) statement, and after the 
program is run the value is set for use in the calling program.
When the program supports the return of a value via a CALL statement,
you can alternatively invoke the program as a function that returns
the value to an expression.

When a program is invoked via a CALL statement, the variable $MODE
in the called program's symbol table is set to "CALL".  When invoked
as a function, the $MODE variable is set to "FUNCTION".

Finally, you can cause the program you CALL to be run on a separate
thread.  More details about thread programming are in the user's
guide topic "Threads."

	CALL PI_TEST(12) AS THREAD(X)

This invokes the function PI_TEST on a new thread (execution context)
that can run at the same time as the current program.  The name of
the thread is returned in the variable X in the above example.

.CHAIN
The CHAIN command transfers control from the current program to
a new program, identified in the command.  Optionally, a starting 
line number in the new program is given to indicate where the 
program is to begin execution.

	CHAIN "program" [, line-number]

The program to transfer control to must be a program already loaded
from a workspace.  The program name is a string expression, so you
can construct a variable or other expression to define the name as 
well as using a string literal. 

You can specify a line number in the program at which to begin
execution after the program name (separated by a comma).

The current program stops execution, and the new program is run 
instead. Only symbols in the current program that are part of a 
COMMON definition are available to the new program.  See the 
documentation on the COMMON statement for more information.

When a program is run via a CHAIN statement, the $MODE variable 
is set to the string "CHAIN" (as opposed to "CALL" or "RUN").  In 
addition, a variable $CHAINED_FROM is created that has the name of
the program that executed the CHAIN operation.  The $PARENT 
variable is the same as the parent of the program that executed 
the CHAIN operation.
.CLASS
The CLASS statement defines the template which is used by the NEW()
function to create objects.  Objects are records with special
properties that link them in a hierarchical relationship.  The CLASS
statement defines the members of the record and a portion of the
hierachical relationship.

    CLASS name [SUPERCLASS name] ( var AS type [, var AS type...])

Each class is given a name, and this name is used to create a
variable containing the class information.  A class may optionally
have a SUPERCLASS which defines a class from which the current CLASS
is derived.  Objects created using the class are defined using the
composive of attributes in the current class and all superclasses.
This is followed by a list of one or more attributes which are
variables and data types.  For example,

    CLASS EMPLOYEE ( NAME AS STRING )
    CLASS MANAGER SUPERCLASS EMPLOYEE( DEPT AS STRING )
    
    BOB = NEW(EMPLOYEE)
    SUE = NEW(MANAGER)
    
In the above example, the class EMPLOYEE is created which has one
attribute, the name.  A second class MANAGER is created which is
a member of the EMPLOYEE class but has additional attributes, which
in this case is a string containing the DEPT string variable.

The variables BOB and SUE are created as instances of each of the
two classes.  Both variables have a record member NAME, but SUE
has the additional attribute of DEPT.  See documentation on the
NEW() function for additional information about container
relationships between objects.

You can use the OBJECT() function to display the object info about
either an object like BOB or a class like MANAGER in the above
examples.

.CLEAR
The CLEAR command is used to remove a stored value or program element
from memory.  The statement can take any of the following forms:

     CLEAR PROGRAM name
     CLEAR FUNCTION name
     CLEAR VERB name
     CLEAR TEST name
     CLEAR SYMBOL name
     CLEAR FIELD file-identifier
     CLEAR MESSAGE name
     
In all the above cases, the name of the item must be given as an
identifier, such as

     CLEAR SYMBOL MYNAME
     
It is an error if the named object does not exist.  Otherwise, it is 
removed from memory. Subsequently it can be recreated by LOAD or RUN 
to load program elements or by creating the symbol again in a statement 
or declaration.

.CLOSE
The CLOSE command closes a file accessed via an OPEN statement.  The
file identifier used in the CLOSE statement must be the same one that
was returned from the OPEN statement.

    CLOSE [FILE] identifier
        or
    CLOSE #integer
    
The keyword FILE is optional when using the identifier name notation.
When a file is opened as a PIPE, it has both INPUT and OUTPUT mode
characteristics, such that PRINT will send information to the pipe's
standard input, and INPUT will read from the pipe's standar output.
Some programs may assume that they will receive an end-of-file on
their standard input to signal that the program is done before they
terminate or even write their output (the Unix 'wc' command is an
example).  You can close a PIPE for further output such that it sends
and end-of-file to the process and can then only be read from to
capture PIPE output with

     CLOSE PIPE FILE identifier
             or
     CLOSE PIPE #integer

You can only do this on a PIPE file once, and you cannot use the
CLOSE PIPE command on any file type other than PIPE.

You can close all open files with the syntax:

    CLOSE ALL FILES
 
You can also close all open files by using the CLOSE command with 
no file specification at all.
.COMMAND LINE
You can invoke JBasic from a command-line.  For example, to run
JBasic using the Java runtime environment, use a command like

     java -jar jbasic.jar
     
You can follow the invocation of the "jbasic.jar" file with command
options specific to JBasic.  These are:

     -help       Print the COMMAND LINE help information
     -noshell    Prevent user command input
     -sandbox    Prevent user programs from manipulating host files
     -server     Start JBasic in multi-user mode
     -e "cmd"    Execute the remainder of the command line as a JBasic
                 statement.
.COMMON
The COMMON statement is used to declare variables in the current 
program that will also be available in any program executed by a 
CHAIN statement from this program.  The COMMON statement has the 
same syntax as the DIM statement.

	COMMON variable [AS type] [, variable [AS type]...]

Variables declared in this way have the "COMMON" attribute, and are
copied to the symbol table of any program that is run via a CHAIN 
statement.  All other symbols in the current program are lost during
a CHAIN operation.

You can also mark a variable as being a COMMON variable by setting
the common attribute in an assignment statement.

	LET MYDATA<COMMON> = "Data to pass to another program"

The <COMMON> tag indicates that the variable is marked as common to
the chained program(s).  Once a variable is marked as being common, 
it cannot be unmarked.

See the documentation on the CHAIN command for more information.

.COMPILE
This statement is used internally to test statement compilation and
optimization, and is not generally useful to the end-user.  The 
statement accepts a complete statement as the rest of the command,
and compiles it into byte code.  The resulting byte code is displayed,
and if it can be optimized, the resulting optimization is also
displayed.  The statement is then executed.

    COMPILE PRINT "This is a test of "; ME
    
The above will compile the PRINT statement, display the resulting
byte code, and then execute the statement.
.CONSOLE
This statement redirects the console output (where SHOW commands, 
PRINT without a file reference, etc.) or input (LINE INPUT and
INPUT wihtout a file reference) to an existing open file.

	CONSOLE INPUT file-reference
	CONSOLE OUTPUT file-reference
	CONSOLE CLEAR
	
Here is a complete example:

     OPEN FILE "STATUS.TXT" FOR OUTPUT AS #1
     CONSOLE OUTPUT #1
     SHOW STATUS
     CONSOLE OUTPUT
     CLOSE FILE #1

The first statement opens an output file.  The CONSOLE statement
then directs OUTPUT (as opposed to INPUT) to the designated file
which must already be open.  The output of the SHOW STATUS command
would normally go to the console but instead is redirected to the
open file #1.  The CONSOLE OUTPUT with no identifier redirects
output back to the conventional console.  Finally the file is
closed.

The CONSOLE command can be given with no additional parameters
in which case it forces the console to be reset to the default.
.CONTINUE
This is used within a DO..LOOP block to transfer back to the top of
the loop body; i.e. "continue with the next loop".  See the help 
for the DO statement for more information.
.DATA
The DATA statement is used to store data elements directly in the
program.  These DATA elements can be loaded into a variable using
the READ statement.

   DATA 3, "Tom"
   DATA {age:40}
   
The above statements defines three constant values.  One is an
integer, one is a string, and one is a RECORD type.  When a 
READ statement is executed, it will read one or more of the
data elements in the program into variables, which can then be
used just as if they came from a LET or INPUT statement.

A DATA statement can only contain constant data, such as numbers
or strings.  However, you can include expressions as long as
all of the parts of the expression are constants, and contain
no variables.

DATA elements can be stored anywhere in the program.  When a READ
statement is executed, it starts with the first DATA statement
in the program and reads the first item in that DATA statement.  The
next READ uses the next DATA element, either in the same DATA
statement or the next one in the program.  When all the DATA has
been read, the next READ statement will read the first item again.

A DATA statement cannot be executed, and cannot be used except in
a program (you cannot use the DATA statement on the command line,
for example).  Because a DATA statement is not executed, the 
physical order of the DATA statements in the program is all that
matters in determining which DATA element(s) to read next - you 
cannot use a GOTO or other statement to change the order in 
which DATA is READ.  

See the REWIND, READ, and EOF() entries for more information.
.DEBUGGER
You can run programs in JBasic under the control of an interactive
debugger by adding the DEBUG keyword to the RUN command.

    RUN DEBUG [program-name]

The DEBUG keyword causes the debugger to be activated, start
at the first line of the program.  The debugger is indicated
by the prompt, usually "DBG> " in place of the regular BASIC
prompt.  At this prompt, you can issue virtually any immediate
mode BASIC command, just like you would at the BASIC prompt.
For example, use the SHOW SYMBOLS command to see the active
symbols in the program or the LET statement to assign a new
value to a variable.

When in the debugger, there are a handful of special commands
that are only available at the DBG prompt.  These control the
operation of the debugger and the program being debugged.

     STEP        Execute one or more statements and then
                 return control to the user for debug
                 commands.
     
     BREAK       Define when the debugger should stop 
                 execution and return control to the
                 user for debug commands.
     
     RESUME      Resume normal execution of the program
                 until the program ends or a breakpoint
                 is encountered.
     
     SHOW CALLS  Display the "call tree" of the currently
                 executing program.

You can request help on any of these additional commands.
.DECIMAL
The DECIMAL statement is used to declare one or more variables of
type DECIMAL, and optionally give them an initial value.

	DECIMAL[(scale)] var1 [= value1][, var2[=value2]...]

The verb DECIMAL can optionally be followed by a scale value in
parenthesis.  The scale indicates the number of decimal places
to the right of the decimal point are maintained.  The default is
zero, indicating that the DECIMAL type is an extended precision
integer value.  This followed by one or or more variable names 
separated by commas.  Any of the variables may optionally be 
followed by a value expression, which is automatically converted 
to a DECIMAL data type before being stored in the variable.

For example,

   DECIMAL(3) P = PI()    // Result is 3.14
   DECIMAL    T = 10/3.   // Result is 3, as scale is 0

.DELETE
The DELETE command deletes lines from the current program.
You can list a specific line, or a range of lines.  If the 
beginning or ending of the range is not given, then the
first or last lines are assumed.

    DELETE 1150                 // Delete line 1150
    DELETE 100-150              // Delete lines 100..150
    DELETE -30                  // Delete lines up to line 30
    DELETE 500-                 // Delete lines after 500

You can use statement labels for line numbers as well.  The
label must exist or an error is reported.

    DELETE INIT - TERM          // Delete lines between INIT and
                                //    TERM statement labels.

If you specific DELETE without giving a range of lines, the
entire program will be deleted from the stored program memory.
If you delete the entire program, there is no "current" program
until the next OLD or NEW statement, or until you start to enter
new program lines.
.DIM
The DIM statement declares a variable and gives it a type.  This is
usually used to create an array (the word DIM is a contraction for
DIMENSIONs), but can be used to create any variable without having
to assign a specific value to it.

    DIM INTEGER X(10)

This statement creates an array with ten elements, each of type
INTEGER.  The array is initialized to the default value for the
type, so in this case it is an array of zeroes.

The type value must be one of BOOLEAN, STRING, DOUBLE, DECIMAL
or INTEGER.

If you omit the size value in parenthesis, then a simple variable
is created of the given type.

    DIM BOOLEAN FLAG

This creates a variable FLAG of type boolean, and sets it to false
by default.  You can specify more than one variable in a single
DIM statement by using a comma:

    DIM INTEGER A, STRING B, BOOLEAN C(10)

This creates three variables: an integer "A", a string "B",
and an array of boolean values called "C".

.DISASM
The DISASM command (like the COMPILE command) is not generally useful
to users, but is used internally to develop and debug issues with
byte code compilation.  Most (but not all) JBasic statements are
compiled into a simpler semantic representation called byte code, which
defines the actual operations required by the JBasic statement given.
The DISASM command is used to list a PROGRAM, FUNCTION, VERB, or TEST
and also display the byte code instructions associated with the JBasic
statements.

    DISASM <type> <name>
    
Where <type> must be one of PROGRAM, FUNCTION, TEST, or VERB.  This
is followed by <name> which is the name of the object to be listed.
For example,

    DISASM PROGRAM BENCHMARK
        or
    DISASM FUNCTION UPPERCASE
    
.DIVIDE
The DIVIDE statement divides an existing variable by an expression.

    DIVIDE X BY 3.0

This calculates the value of X/3.0 and stores the result
back into the variable X, which must already exist.  This is
semantically identical to LET X = X / 3.0

.DO
The DO loop creates a loop that runs until an expression gets either
a true/non-zero value, or a false/zero value, depending on the form:

    DO
        ...statements...
    
    UNTIL boolean-expression

The boolean-expression is any expression that results in a boolean
(true/false) or numeric value.  If the result is false or zero
then the loop runs again.  If the result is true or non-zero, then 
the loop exits and execution of the program continues after the UNTIL
statement.


    DO
        ...statements...
    
    WHILE boolean-expression

The boolean-expression is any expression that results in a boolean
(true/false) or numeric value.  If the result is true or non-zero
then the loop runs again.  If the result is false or zero, then 
the loop exits and execution of the program continues after the WHILE
statement.  

In both these cases, the condition is tested at the bottom of the
loop by default, so the loop will always run once.  You can change
this by using SET LOOP_OPT, which tells JBasic to evaluate the
condition before executing the code even once, so loops may not
run at all if the condition precludes looping.

You can also force the condition to be evaluated at the top of the
loop by specifying it on the DO statement, as in:

    DO WHILE boolean-expression
       ... statements...
    LOOP
    
You can use DO WHILE or DO UNTIL in this format.  The expression
in this case is always evaluated at the start of the loop.

You can use the CONTINUE statement within the body of a loop to
transfer control back to the top of the loop. You can use the 
END LOOP statement to transfer control out of the loop body
from within the loop.  For example,

    DO WHILE RUNNING > 10
       T = NEXT_ONE(RUNNING)
       IF T THEN END LOOP
       CALL MORE(RUNNING)
    LOOP
    PRINT "Done with loop"
    
In this example, the test to see if T is true can result in the
loop terminating and control resuming at the PRINT statement.  The
END LOOP and CONTINUE statements can only be used inside a DO
loop.
.DOUBLE
The DOUBLE statement is used to declare one or more variables of
type DOUBLE, and optionally give them an initial value.

	DOUBLE var1 [= value1][, var2[=value2]...]

The verb is followed by one or or more variable names separated by
commas.  Any of the variables may optionally be followed by a value
expression, which is automatically converted to a DOUBLE data type
before being stored in the variable.
.END
The END statement terminates the current program (and any program that
called it) and closes all files opened by the user. 

	END

Any files opened by any program or by immediate mode statements are closed,
except those opened with the SYSTEM attribute.  Additionally, this terminates
all programs in the current "stack" of called programs.  That is,

    In program FOO:
    
         CALL BAR(3)
         PRINT "Done"
         
    In program BAR:
    
         PRINT "Almost"
         END
    
In this sequence of code, the message "Almost" will be printed, but the
END statement terminates BAR and FOO, so the message "Done" will not be
printed.
.END IF
This is used to terminate a multi-statement IF-THEN-ELSE block.  See the help
for the IF statement for more information.
.END LOOP
This is used to exit out of the body of a DO..LOOP block.  See the help for
the DO statement for more information.
.EXECUTE
The EXECUTE verb allows a string expression to be executed as a
language statement.  This allows a program to create a line of
program code and have it interpreted by JBASIC.

    EXECUTE string-expression [ RETURNS variable ]

If the statement contained in the result of the string expression
gets an error, then the EXECUTE statement is considered in error
and the program halts.  You can use the RETURNS clause to capture
the result of the statement in a variable; in this case the EXECUTE
statement does not have an error, but the status information that
describes the error from the statement is stored as a record in 
the RETURNS variable.

If the statement being executed was taken from user input, it may
be necessary to run the statement in a protected "sandbox" mode
where the statement effectively runs without permission to modify
the host environment (for example, it cannot access or delete files).

    EXECUTE SANDBOX CMD_STRING RETURNS STS
    
This example executes the command in the string CMD_STRING in the
sandbox mode, and sets any return code value in the variable STS,
which contains a record describing if the command ran with or 
without error.  If the command performs a privileged operation, the
STS variable can be used to catch this and take programatic action.

You can execute a statement on a new thread, which causes the statement
to execute concurrently with the main program.  See the user's guide
documentation on "Threads" for more information.

    EXECUTE "RUN PAYROLL_DATA" AS THREAD(X)

This causes the command RUN PAYROLL_DATA to execute on a new JBasic
thread.  The current environment or program continues to execute, and
the new statement also executes at the same time.  If your computer 
has more than one CPU core in it, these programs can literally execute
simultaneously.  The name of the new thread is stored in the variable
X in the above example.  Use SHOW THREADS to display the threads and
their current state (running, stopped, etc.).
.EXPRESSIONS
Expressions refer to sequences of JBasic code that are evaluated
(calculated) to derive a result.  Expressions most often are
evaluating numeric values, but some involve string values as well.
In general, expressions can appear anywhere that a value must be
calculated and used, but are not used to describe where to store
information.

The statement

    LET X = 3*X+5
    
is perfectly valid, because the expression (3*X+5) is being used
to calculate what value is to be stored in X.  However, the statement

    LET X+3 = Y

is not allowed, because the LET statement requires that the left
side of the "=" be a variable and not an expression.  The LET,
INPUT, READ, and FOR statements all have these limitations on 
operations that store into a variable.  Anywhere else that 
shows that a numeric or string value is required can contain an
expression.

Numeric expressions are those whose terms are all numeric, or are
expected to be converted to numbers automatically (see the help
on VARIABLES for more on conversions).  The operators that are
used to perform the calculations in a numeric expression are:

    +       Add two numbers together
    -       Subtract two numbers
    *       Multiply two numbers
    /       Divide two numbers
    ^       Raise left number to the power of the right number

For example, consider the following simple segment of JBasic code:

    LET X = 3.5
    LET Y = 2
    
    PRINT X*Y

The result is calculated by multiplying the value of X (3.5) by the
value of Y (2), and the result of the expression is output using the
PRINT statement.  The output would be the value 7.  Similarly, the
statement PRINT 2^8  results in the value 256 being printed.

Expressions follow an "order of precedence" just like they do in 
conventional mathematical operations.  Multiplication and division
operations are done first, followed by addition and subtraction.

     PRINT 3 + Y * X
     
Will print the value 10, because the multiplication of X*Y is done
before the value 3 is added back in.  You can use parenthesis to
group things together to control the order of evaluation.

    PRINT (3+Y) * X

This will print the value 17.5, since the addition of Y and 3 will
happen first, followed by the multiplication by X.  You can use more
than one set of parenthesis, and they can be "nested" inside each
other to control the evaluation of complex expressions.

    PRINT ((1+3)*(5-2))/2
    
This results in the value 6 being printed.  The inner parenthesis
expressions are calculated first, then the next-outermost and so on.
The above expression is like typing

    PRINT (4*3)/2
    
which is the same as typing

    PRINT 12/2

The above examples all use numeric values.  But you can express
some kinds of operations using string values as well.  The string
operators are:

    ||      Concatenation, which adds one string to the end of
            another string.
            
    -       Subtraction, which removes a string value from another
            string (essentially deleting a portion of a string)

For example, the statement

    print "Tom" || "Cole"
    
Will print out the string TomCole.  Note that there is no space
between the items, they are added directly together.  Here is an
example of using subtraction to delete a string:

    print "Tom Cole" - "m C"
    
Which prints the value "Toole", since the part that was subtracted
has been deleted from the string.  If you attempt to delete a string
that is not there ("Tom" - "Z") then the result is the first string
without any changes.
.FIELD
The FIELD statement defines a record format to be used with a BINARY 
file accessed via OPEN, PUT, and GET statements.  The FIELD statement
creates a named object that describes how to move data from the file
to variables in memory and vice versa.

    FIELD name AS type name [, type name[, type name...]]
    
Records must have a valid name.  This cannot be the name of any other
variable or language keyword.  The AS clause contains a list of one or
more type and name combinations.  These are the same format as the
GET and PUT command strings.  For example,

    FIELD EMPREC AS STRING( 30 ) NAME, INTEGER ID
    PUT FILE BD, USING EMPREC, FROM { NAME : "Tom", ID : 2001 }

The first statement defines the record EMPREC which has two fields, a
30-character string called NAME and an integer called ID.  The PUT
statement has a USING clause that defines the record definition that
describes what data is to be written to the file. The EMPREC tells
the PUT statement to find fields named NAME and ID and write them 
out to the file from the FROM clause's data record.

The length value for the field types STRING and VARYING must be
given as an integer in parenthesis; this tells how much space to 
reserve in the record for the string data. The difference between
STRING and VARYING is that STRING data is of fixed length (the size
specified in the FORMAT) whereas VARYING data has an extra integer
length written to each buffer that tells how long the string really
is within the buffer.  Note that this means that VARYING should not
be used when attempting to read string data from binary files created
outside of JBasic.

You can also specify a bitfield in a FIELD statement.  A bitfield is
a string of bytes that are broken down into integer values of varying
width.  A bitfield integer can be from 1-64 bits in width.

    FIELD EMPREC, BITFIELD(1 AS GENDER, 15 AS ID), DOUBLE AS SALARY
    
This creates a field definition for three variables.  The variable
GENDER will be read or written as a single bit (0..1) and the ID
variable is written as a 15-bit value (0..16383).  BITFIELD values
are always positive integers.  When this FIELD is used in a PUT
statement, the value of GENDER is expressed as single bit and
the value of ID is expressed as a 15-bit positive integer.  The
variable SALARY is treated as a normal floating point value.

You can specify explicit bit positions, as a zero-based index into
the bit buffer being manipulated.  This is used to skip over unused bits
in the value being read or written.

   FIELD HEADER, BITFIELD(1 @ 2 AS FLAG, 3 AS KIND)

This creates a bitfield for a single byte, but only bit position
2 (in a zero-based system) and bit positions 3-6 will be used. 
When the "@" is omitted, then the next field is assumed to be
at the next available bit position.

Note that FIELD is a statement that defines a "map" of how data is
to be read or written using GET and PUT statements.  This is in
contrast to RECORDS which are a data type containing one ore more
named fields in memory.  The above syntax creates a FIELD that tells
how to read and write RECORDS.

You can "bind" a FIELD specification to a given file so that you 
do not have to specify the USING clause.  For example, 

    FIELD #3, STRING( 30 ) AS NAME, INTEGER AS ID
    PUT #3

This writes the values of NAME and ID to the BINARY file #3 using
the FIELD specification given.  Because the FIELD statement is an
executable statement, each time you execute the FIELD statement,
the record definition is changed.  This record definition is used
by PUT, GET, and SEEK statements when no USING clause is given.

Since the FIELD with a file specification requires an open file,
you can define a FIELD using a named object and then assign it
to a file later, using:

  FIELD EMPDATA, STRING(30) AS NAME, INTEGER AS ID, FLOAT AS SALARY
      ...
  OPEN BINARY FILE "EMPLOYEES.DAT" AS #5
  FIELD #5 USING EMPDATA

This causes the field definition EMPDATA to be assigned to the 
binary file #5, so subsequent GET and PUT statements will use the
definition of EMPDATA.
  
You can remove a FIELD definition from a file with the CLEAR
statement, such as:

    CLEAR FIELD #5
    
This removes the FIELD definition for file #5.  Subsequent BINARY
file operations will assume no field definition and must include
a USING clause, etc. as appropriate.

.FILES
The FILES command lists files in the current directory, or in a
directory given in the command:

    FILES ["path"]

If omitted, the default directory is assumed.  If a specific directory
is to be listed, then that must be expressed as a string constant.  More
than one path can be specific on the command line.  For example,

    FILES "bin", "src"
    
This displays the files in the "bin" and "src" subdirectories.
.FIND
The FIND command is used to search for one or more strings in the current
program.

     FIND "string"  [, "string"...]

All lines of the current program that contain any of the given strings
will be printed.  If there is no current program, then an error occurs.
If no instances of the string are found, then a message is printed.
.FOR
The FOR statement creates a loop with an index variable that changes
value by an incremental value each iteration of the loop.  The loop
executes as many times as it takes to increment the index variable
past a limit.

    FOR index = start TO end [ BY increment ]
        ... statements ...
    NEXT index

The 'index' is a variable that is initially assigned the 'start' 
value.  The statements are executed, and when the NEXT statement
is executed, the index variable has the 'increment' value added
to it.  If the increment was not specified, then 1.0 is assumed.
The index is then compared to the 'end' value, and if the end
value has been exceeded (greater than it if the increment is
positive; less than it if the increment is negative) then 
the program continues executing with the next statement after the
NEXT.  Otherwise, the statement body is executed again.

If the index value is already past the limit, the loop does not
run at all, but execution continues following the NEXT statement.
An increment with a value of zero signals an error.

An alternate syntax allows the index variable values to be given
as an explicit list.

    FOR index = [EACH OF] v1 [, v2 [, v3...]]
       ... statements ...
    NEXT index

In this case, the values are either scalar values like strings
or integers, or they can be arrays.  The index variable is set
to each value in turn and the statement(s) in the loop are
executed accordingly.  If the value is an array, the index is
set to each member of the array.  In the statement syntax, The 
keywords EACH OF are optional.

The following example program prints out the symbols in each of
the symbol tables, by using this syntax.  This works because the
TABLES() and SYMBOLS() functions each return arrays that can be
traversed implicitly using this syntax.

  100   PROGRAM FE
  110   // Version: 1.0
  120   // Date:    Mon Jul 16 19:36:33 EDT 2007
  130   // Author:  tom
  140   FOR I = EACH OF TABLES( )
  150     FOR S = EACH OF SYMBOLS( I )
  160       FOR T = EACH OF S
  170         PRINT I, T
  180       NEXT T
  190     NEXT S
  200   NEXT I
  
.FUNCTION
The FUNCTION statement in a stored program declares a function,
which takes zero or more arguments and returns a single value.

    FUNCTION name ( arg [, arg...] )

The function is later called by the given name.  The caller must
supply at least as many arguments as are declared in the function.
If there are no arguments, use empty parenthesis.  If there are
to be variable numbers of arguments, end the argument list with
an ellipsis ("...") indicator.

Because in JBasic, data elements are largely type-less, the 
function does not have a declared type. Rather, the RETURN
statement is used in the function to pass a result back to
the caller, and has whatever type the resulting data is.

A FUNCTION can explicitly declare the types of arguments by
putting a type name before the argument.  For example,

    FUNCTION FOO( DOUBLE V, INTEGER COUNT)
    
This declares a function whose first parameter will always
be converted to a double before being stored in the local
variable "V" in the function, and a second variable "COUNT"
which is coerced to an integer in the function's program.

You can also declare a default value for a parameter that
is not given.  Any parameter with default values must come
after all parameters without default values.  For example,

   FUNCTION FOO( DOUBLE V, INTEGER COUNT=10)

This version of the function FOO accepts one or two parameters.
If the second parameter is not given, then a value of 10 is
assumed.

Finally, you can specify variable untyped parameters by using
the ellipse:

   FUNCTION BAR( INTEGER COUNT, ... )

The function must have at least one parameter, which is the
integer COUNT.  It can accept any number of additional 
parameters.  These are available in the array $ARGS which
is a readonly local variable available to the executing
function.  The expression LENGTH($ARGS) will tell how many
arguments (including the integer COUNT) were supplied.

The function invocation can be included in any expression,
and there is no distinction between stored program functions
and intrinsic functions built into JBasic as far as how they
can be used or called.  See HELP INTRINSIC for a list of the
builtin functions.  Use the SHOW FUNCTIONS command for a
runtime list of the built-in and stored program functions.
.FUNCTIONS

THIS HELP WILL NEVER BE DISPLAYED.  The .FUNCTIONS keyword 
is here to be a place holder for the HELP TOPICS display.  
However, HELP FUNCTIONS is also a special case, and really 
scans for the ":" prefixed function names.
.GET
The GET statement is used to read one or more values from a BINARY
file.  Data in a BINARY file is not stored as human-readable text, but
instead is stored in the native binary format for integers, floating
point numbers, character strings, etc.  A BINARY file has a current
position (which can be determined using the GETPOS() function, or set
using the SEEK statement).  This position defines where the next GET
statement or PUT statement will read or write data.  Once data has been
read, the pointer advances to the next unread byte of data.

The GET statement has two forms.  The first form explicitly lists the
types and names of each variable to read from the file:

     GET FILE <id>, <type> [(size)] <variable> [, <type> <variable>...]
     
The statement requires a FILE identifier, typically the identifier
created by the OPEN statement.  This is followed by a comma-separated
list of types and variables. The size may be specified in parenthesis
for strings that are fixed-length string values.  The allowed types
are:

     INTEGER         A 32-bit integer value
     DOUBLE          A 64-bit floating point value
     BOOLEAN         An 8 bit value that is either 0 or 1
     STRING          A string variable of fixed length
     VARYING         A string variable of varying length
     
In the case of a string variable, the size of the value must be given
in parenthesis after the keyword STRING, as in STRING(20). This
indicates that the string takes up 20 characters of space in the file
even if the actual string value is shorter.  See the help on the
SEEK statement for more information on why this is important.

The same is true of the VARYING specification. The difference between
STRING and VARYING is that STRING data is of fixed length (the size
specified in the FORMAT) whereas VARYING data has an extra integer
length written to each buffer that tells how long the string really
is within the buffer.  Note that this means that VARYING should not
be used when attempting to read string data from binary files created
outside of JBasic.

The second format of the GET statement assumes that the contents of
the file (or a set of items to read from the file) are defined using
an ARRAY of RECORD values describing what to read.  For example,

    EMPREC = []
    EMPREC = EMPREC + { TYPE:"STRING", SIZE:20, NAME:"EMPNAME" }
    EMPREC = EMPREC + { TYPE:"INTEGER", NAME:"EMPID" }

    GET FILE EMPDATA, USING EMPREC

The value EMPREC must be an array, each element of which is a record
that describes the next item to read.  The record must have a field
named TYPE containing a string with the given type, and a field named
NAME containing the name of the variable in which to store the value.
A SIZE field may optionally be used to define fixed with string sizes.

The GET...USING clause uses the contents of the array (EMPREC in the
above example) to read in two values, a 20-character string and an
integer.  These are stored in the variables EMPNAME and EMPID when the
GET statement completes.  The EMPREC record can be used to read or write
data (see the PUT statement for more information) as many times as
needed.  So the above sample code defines the contents of the data in
the file for an employee, and each GET..USING or PUT..USING statement
uses the same data definition.

You can also store a record definition for the file using the FIELD
statement, which allows you to issue GET statements for a file without
having to explicitly specify the fields each time. See the documentation
on the FIELD statement for more information.
.GLOBALS
The GLOBAL symbol table contains variables that are created automatically
as part of JBasic initialization. They can be used to check the state of
the environment that a JBasic program is running in, or can be used to
control certain aspects of how JBasic works.  Here are some of the more
interesting global variables and what they are used for:

   SYS$$STATEMENTS           Counts the number of statements executed
                             during the entire JBasic session.
                             
   SYS$ARGS                  An array containing the arguments that
                             were given to JBasic from the command line.
                             
   SYS$INPUT_PROMPT          This is the default prompt string used for
                             INPUT and LINE INPUT statements.
                               
   SYS$STATUS                The message code of the last error
   
   SYS$OPTIMIZE              If true, allows the compiler to optimize the
                             intermediate code for a statement.  This means
                             it takes longer to load a program, but the
                             program runs faster.
                             
   SYS$PROGRAMS              An array containing the names of all program
                             objects currently in memory.
                             
   SYS$PROMPT                The default prompt string for immediate mode
                             commands.
                             
   SYS$RETOKENIZE            If true, statements are reformatted as they
                             are loaded or typed into the current program
                             to be more uniform in format and appearance.
   
.GOSUB
The GOSUB statement transfers control to another statement in the
current program, identified by a label.  Unlike GOTO, when the
program executes a RETURN statement, control will return to the
statement following the GOSUB.  This allows internal, non-
parameterized subroutines to be written in the current program.

    X = 3
    GOSUB DOUBLE
    PRINT X
    RETURN
    
DOUBLE:
    X = X * 2
    RETURN

The above program will cause X to be set to 6.  The GOSUB
statement transfers control to a line within the same program
that executes a RETURN when it is ready to return control to
the program statement that called it.  This allows for simple
subroutines to be implemented within the program for performing
commonly performed operations that can be called from many
places in the same program.
.GOTO
The GOTO statement transfers control to another statement in the
current program, identified by a label.

    GOTO name
        or
    GOTO USING( expression )
    
The destination label can be identified by a name such as TRY_AGAIN
or by a USING clause with an expression that resolves to the name
of the label.  The label itself is always a name followed by a single
colon, optionally followed by the first statement executed at that
label.

     GOTO TRY_AGAIN
     ...

TRY_AGAIN:
     PRINT "We are going to try again"
     ...

.HELP

The HELP command displays information about commands.  To see a list
of help topics, use HELP TOPICS.

.IF
The IF statement is used to conditionally execute a statement.  The
IF statement uses an expression that is tested to see if it is a
true or non-zero statement.  

    IF X=3 THEN PRINT "We win!"

If the value of X is equal to 3, then the PRINT statement is executed.
IF X is not equal to three, then the next statement in the program
is executed next.

You can have IF statement include a statement to be executed if the
condition is false.

    IF X = 3 THEN PRINT "winner" ELSE PRINT "loser"
    
In this case, if X is 3 then "winner" is printed. If X is not
3, then "loser" is printed.  In either case, the next statement
will be executed next.

Note that IF statements can contain GOTO statements that will
effect flow of control in the program.  The IF..THEN..ELSE
statement above could have been written as

    IF X = 3 THEN GOTO WINNER
    PRINT "loser"
    GOTO DONE

WINNER:
    PRINT "winner"

DONE:

This code segment will use GOTO to conditionally choose a block
of code to execute.

You can also optionally express the statements to be conditionally
executed across multiple lines of code by terminating the IF statement
with the THEN keyword, which tells JBasic to look for an optional ELSE
statement and an END IF statement to terminate the block(s) of statements
to execute if the condition is true or false.  For example,

     IF SALARY > 12 THEN
        W = HOURS * SALARY     // The "true" statements
        PRINT "STRAIGHT SALARY"
     ELSE
        W = HOURS * SALARY * 1.2  // The "false" statements
        PRINT "ADJUSTED SALARY"
     END IF

The "true" statements will be executed if the condition is true (in
this case, SALARY is greater than 12).  The statements in the ELSE
block will be executed if the condition is false. If no ELSE clause
is required, just end the "true" block with the END IF statement.

.INPUT
The INPUT statement is used to prompt the user for a value or list of
values, and store them in JBasic variables.

    INPUT [FILE identifier,] ["prompt",] identifier [, identifier...]

If the FILE keyword is given followed by a file identifier, then the
input is taken from the named file.  Otherwise, the user's console
is prompted.  If the prompt string is not given, then "? " is used.
The user types in one or more values separated by commas, which are
assigned in the same order as they are given to the identifiers
in the INPUT statement.  For example,

    INPUT "Enter three scores: ", A, B, C
    
    Enter three scores: 33,55,13

The prompt string is displayed and the user enters three values.  The
variable A will contain 33, the variable B will contain 55, and the
variable C will contain 13.

You can optionally specify a data type after any variable name, which
causes the input value to be converted to the given type before being
stored in the variable.  For example,

    INPUT "Enter your name: ", NAME AS STRING

This converts the input value to a string data type before storing in
the variable NAME.  You can also specify a type of XML to read an XML
representation of a data value:

    INPUT #1, MYREC AS XML

This reads as many characters from file #1 as required to locate a valid
and complete XML item.  The item is parsed as a JBasic value and stored 
in the variable MYREC.  If the file does not contain a complete XML
specification, then an end-of-file error is produced.  If the file 
does not contain a valid JBasic value XML item, then a SYNTAX error
is generated.  After the INPUT statement, the file is positioned
at the next non-blank character after the end of the XML specification,
so additional values or XML strings can be read sequentially.

If the XML is being read from the console, the user can enter .END
to terminate the input and processing of the XML.

If the XML uses a non-standard root tag, you can specify the root tag
to find the value in the XML:

    INPUT #1, USERD AS XML("USERDICTIONARY")
    
This scans the input for an XML root tag of "USERDICTIONARY" and then
reads a JBasic Value from that XML object.  The tag name is not case
sensitive.  If no tag name is given, "VALUE" is assumed.

Another use of the INPUT statement is to allow the user's input to
include identifiers which enumerate which fields in the input are
meant to contain which values. This is converted to a record that
you can process.

    INPUT "Parms? ", FOO BY NAME
    
This creates a record named FOO which contains a member for each
named input in the user input line.  If the user enters X=3,Y="M"
then the record contains two members X and Y with the given user
supplied values.  The program can use the MEMBERS() function to 
learn the names of the values given by the user.

An alternate approach is to let the input determine which values
will go directly to program which variables you specify in the
INPUT statement. For example,

    INPUT "Parms? ", BY NAME( AGE, GENDER, NAME )

The user is prompted and enters a line of text that includes the
given names, an "=", and a value. These can be in any order.  For
example,

    Parms?  GENDER="F", AGE=35, NAME="Sue"

When the statement completes, the three variables are given the
values named by the user. If the user does not give a named value
for a variable in the BY NAME() list, then that variable is set
to a double missing value (NaN).  If there is a syntax error in 
the  user's input, all variables are set to NaNs.  You can specify
a different name for the user to specify than the variable it
is assigned to, as in

     INPUT "Parms? ", BY NAME( PARM1 AS P1, PARM2 as P2)
     
In this case, the user input must reference P1 and P2, but the
values are stored in variables PARM1 and PARM2.  This allows
you to specify simplified names for the user input.

If the user specifies values that are not in the BY NAME() list,
they are normally ignored. However, you can capture a list of
the unexpected variables using the REST AS clause:

    INPUT BY NAME(USER, PASSWORD) REST AS EXTRAS

If the user's input contains any values other than PASSWORD and
USER, the names of the values are stored as record named EXTRAS
If there were no unexpected values in the input then the record
will be empty.  Otherwise the record contains the names and
values that were unexpectedly found in the input.

You can use the INPUT statement to read rows into a TABLE data
type as well.  In this case, the number of elements read from
the input stream and their data types is controlled by the 
TABLE definition.  Consider the following code:

    TABLE E AS INTEGER ID, STRING NAME
    INPUT ROW OF E

The "ROW OF" syntax tells the INPUT statement that you are
reading a row of an already-existing table (in this case,
the table E). A default prompt is generated if no prompt
string is given, which identifies the names of the columns:

    ID, NAME? 101 Tom

Here the prompt identifies the column names, and the input
includes the id 101 and the name "Tom".  These are added at
the end of the table as a new row.

.INTEGER
The INTEGER statement is used to declare one or more variables of
type INTEGER, and optionally give them an initial value.

	INTEGER var1 [= value1][, var2[=value2]...]

The verb is followed by one or or more variable names separated by
commas.  Any of the variables may optionally be followed by a value
expression, which is automatically converted to a INTEGER data type
before being stored in the variable.

.INTERRUPT
It is possible to write a program in JBasic that does not end.  For
example, consider the following:

             PROGRAM ENDLESS
    LOOP:    GOTO LOOP

The program named ENDLESS will run forever, because it has been 
directed to transfer control to the GOTO statement over and over
again.

You can stop an endless loop (or any long-running JBasic program) by
using the console interrupt function.  Normally this is control-C on
DOS, Mac OS X, and VMS consoles.  On Unix systems, this is whatever
the INTR key is set to.  When you press this key during a running
program, a signal of INTERRUPT is generated for the next statement to
execute. This signal causes the program to terminate and return to the
command prompt with an error message:

    BASIC> run
    ^C
    In program ENDLESS; interrupted by user
    BASIC>

Because the interrupt is a signal like any other, you can use an ON
statement to catch the interrupt request and execute a GOTO statement
to process the interrupt in a fashion appropriate to your program, 
such as saving any data being processed currently, etc.

Please note that the interrupt function will not work when JBasic is
being run within Eclipse, because Eclipse does not have the ability 
to send the native interrupt signal.  In this case, just stop the
JBasic thread using the "Terminate" button.

.JAVA OBJECTS
You can directly manipulate Java objects from within JBasic, with
some limitations.  This is intended to support interoperability with
other elements of a larger Java software architecture, such as using
JBasic as a scripting agent to control interactions between other
objects.

Java objects look a lot like a RECORD to JBasic, but have a few
additional special properties and some limitations.  Java objects
are created in JBasic in one of three ways.  First, a JBasic program
can create a new instance of a Java object with the NEW() function.
Secondly, a program that is using JBasic as an embedded language
processor can store Java objects in a JBasic global variable via a
method call to JBasic.  Finally, external statements or functions
that are executed within JBasic can create new JBasic values from
any arbitrary Java object.  Of these three means, only the first
is documented here as it is the only mechanism done directly with
the JBasic language.

To create an instance of a new object, use the NEW() function with
either a string containing the fully qualified class name, or with
another previously-created Java object whose class is used to create
the new object.  For example,

	MYSTRING = NEW("java.lang.StringBuffer")

Note that the class name must be in mixed case, and must exactly
match a class name visible to the Java class loader.  This means 
you can't arbitrarily name classes that are not included in the
Java CLASSPATH for JBasic.

In the above example, a Java StringBuffer object is created.  If
the Java object has a constructor with parameters, you can put them
after the class name in the NEW() invocation, such as the following:

    MYSTRING = NEW("java.lang.StringBuffer", INITSTRINGVAL )

In this case, if INITSTRINGVAL is a STRING variable, it will be 
passed as a Java String to the constructor.  In the case of a Java
StringBuffer, the constructor with a string parameter uses the 
string to set the initial contents of the mutable string buffer.
This would be similar to the Java code:

	StringBuffer myString = new StringBuffer(initStringVal);

You can call methods for this object in two ways, via the CALL 
statement for methods that do not return a value, or via method 
function in an expression.

The first example is demonstrated with this call to the append() 
method of the StringBuffer class.  In this case, two strings are
being appended to the buffer:

	CALL MYSTRING->APPEND("This &")
	CALL MYSTRING->APPEND(" that")

Note that the actual Java method name is "append" but the name we
give is not case-sensitive; JBasic converts all identifiers to
uppercase automatically.  Because of this, you cannot call a
method that has an ambiguous name if case-sensitivity is not
considered.  That is, a method of isMyField() and isMYField()
are two different methods in Java, but ambiguous in JBasic. Such
a method call will fail and you will need to consider creating
a wrapper Java object with unambiguous names.

The above method call passes a string.  You can pass a string, 
integer, double, or boolean as arguments to a method. Additionally,
you can pass any arbitrary Java object as a parameter, in which 
case the underlying method must support the actual class of the
Java object to be valid.  You cannot pass arrays, chars, or other
data types in Java that do not have a JBasic equivalent.  Again,
if you need to pass different data types, consider creating a
wrapper class for the Java object that translates the supported
JBasic argument types into the richer Java argument set.

You can also call a method as a function call in an expression.
In this example, the toString() method is called to convert the
string buffer created in the previous example to a standard string.

    X = MYSTRING->TOSTRING()

Again, note that the toString() Java method must be unambiguous
when converted to uppercase.  The "->" notation with a method 
name and an argument list signals a method call.  The resulting
value is a string, stored in the variable X, that contains the
text "This & that", created by the previous append() method calls.

Some objects allow direct manipulation of some of their fields.
In this case, you can reference those fields as if they were
fields in a RECORD.  For example,

	OBJ = NEW("my.domain.MyObject")

This creates a Java object reference to a newly created object
of the class my.domain.MyObject, which must be loadable via the
CLASSPATH.  Let's assume that this object has a public String
field called myName and a public int field called myAge.  If
you print OBJ, you will see these fields in the RECORD that
represents the Java object:

    BASIC> PRINT OBJ
    { MYAGE: 49, MYNAME: "Tom" }
    	
Note that - like method names - the field names are converted to
uppercase, and must be unambiguous when expressed in uppercase.
You cannot have a field named "age" and one named "Age" in the
same class or an error occurs.  You can reference the field values
in an expression, as in:

   OBJ.MYAGE=50
   PRINT OBJ.MYAGE

Unlike a JBasic RECORD, you cannot create new fields by assigning
a value to them; you can only reference fields that actually exist
in the Java object.  The MEMBERS() function will return a list of
the fields in the Java object just as it would in a RECORD.

If the Java class has static fields, these are available in the
Java object but are not normally printed out or included in the
MEMBERS() list.  To reference a static field in the Java object,
you must precede its name with an "_".  Suppose the MyObject class
used in the above example includes a static int value of adultAge
with a value of 18.  You would not see it in the PRINT command of
the object, but you could reference it as OBJ._ADULTAGE.  If you
use the optional second parameter to the MEMBERS() function you
can see the list of static fields as well as the object fields,
as in MEMBERS(OBJ,TRUE) which will include the static field names
in the list.

.KILL
The KILL statement is used to delete a file or directory.  The 
argument is a string containing the name of the path or file.  To
delete a directory, the directory must be empty.

    KILL "names.txt"

The statement will return an error if the file does not exist, or
if security restrictions prevent the file from being deleted.

You can also KILL an open file by referencing it using it's file
handle:

    KILL FILE MYFILE
    
The handle variable MYFILE must reference an open file.  The file is
closed and deleted; after this statement the file handle is no longer
valid.
.LET
The LET statement assigns a value to a variable.  If the variable does
not exist, it will be created.  If the variable is READONLY then an
error is signaled

    [LET] variable = expression

The verb LET does not have to be explicitly in the statement, though it
will be added automatically by JBasic.  The variable's type is set to
whatever type the expression result is, even if that is different than
what the variable previously was.  For example,

    X = 33
    X = "Test"

This is a valid sequence of statements, and after both statements are
executed, the variable X will be of type string.

A variable can be created that is an array, simply by specifying an 
array index in the left side of the expression.  For example,

    NAMES[3] = "Mary"

If the array NAMES does not exist, it is created, and the third entry
is set to the string "Mary".

.LINE INPUT

The LINE INPUT command reads a complete line of text from a file or the
console into a single variable.  An optional prompt string can be given
that is printed if input is from the console.

    LINE INPUT [ FILE identifier ] [ "prompt text", ] variable-name

If the FILE clause is used the input comes from that file, and the
prompt string is not used.  If there is no FILE clause, then the
prompt string is printed on the console before keyboard input is
accepted.

.LIST
The LIST command lists the current program to the console. 

    LIST
    
    
The program is output in a formatted fashion, as opposed to the
exact spacing as originally entered.  If you set the boolean
value SYS$DISASSEMBLE to true, the LIST command will also dump
out the compiled byte code for each statement that can be pre-
compiled.

You can list a specific line, or a range of lines.  If the 
beginning or ending of the range is not given, then the
first or last lines are assumed.

    LIST 1150                 // List line 1150
    LIST 100-150              // List lines 100..150
    LIST -30                  // List lines up to line 30
    LIST 500-                 // List lines after 500

You can use statement labels for line numbers as well.  The
label must exist or an error is reported.

    LIST INIT - TERM          // List lines between INIT and
                              //    TERM statement labels.

.LOAD
The LOAD statement loads a text file into memory as an executable
program element. The text file can contain one or more program,
function, verb, or test definitions.

    LOAD "filename"

After the LOAD completes, you can use the SHOW PROGRAMS command to
see the names of all programs in memory.  Programs with an asterisk
next to the name are user programs that were invoked via a LOAD
command, and programs with a sharp-sign "#" next to them have been
modified and will be discarded unless a SAVE or SAVE WORKSPACE
command is given.

The LOAD statement can also be used to load an XML definition of
a program.  This XML definition must have been created as a JBasic
PROGRAM() value converted to XML.  For example, the following will
write out a file containing the XML for the $ABOUT program:

     OPEN FILE "ABOUT.XML" FOR OUTPUT AS #1
     PRINT #1; XML(PROGRAM("$ABOUT"))
     CLOSE #1

This uses the PROGRAM() function to create a variable that fully
defines the $ABOUT PROGRAM, and the XML() function to convert this
to valid XML.  This is written to the file "ABOUT.XML".  Later,
this program can be loaded back into memory from the file using

    LOAD "ABOUT.XML"
    
The LOAD statement detects that the file contains XML and parses
the XML appropriately to load the program into memory.  In this
form, the file can contain only one program definition.
.LOCK
The LOCK command is used to create a lock if it doesn't already
exist, and the put a hold on the lock so no other JBasic thread
in the current program can access the lock. Specify one or more
lock names in a list:

   LOCK COUNT_L, COUNT_Q

The example above creates locks COUNT_L and COUNT_Q (if they don't
already exist) and then holds the locks.  This will prevent any 
other thread from being able to acquire the same locks.  You can
specify USING(string-expression) instead of a lock name if the
lock name must be derived indirectly.

Another thread that executes a LOCK statement for the locks will 
wait until that lock is released by the thread that holds it.  
The UNLOCK statement is used to release locks so other threads 
that want the locks can then acquire the locks.

Consider the following sample code:

      LOCK COUNT_L
      COUNT = COUNT + 1
      UNLOCK COUNT_L

If this same code is executing simultaneously in more than one thread,
there is a risk that the threads will interfere with each other.  The
first thread will load the value of COUNT, and add 1 to it.  The second
thread would then load the same value of COUNT and add 1 to it.  The
first thread would write the newly updated value back to COUNT, and
then the second thread would write the *same* value back to COUNT.  

The result is that - depending on the order of instructions being 
executed simultaneously - both threads will attempt to increment COUNT 
but it will effectively only be incremented one time.  By using the LOCK
and UNLOCK statement in this case example, each thread can be guaranteed
to have exclusive execution control during the time they hold the lock,
and the increment of COUNT will be completed on one thread before it 
can run on another thread.

.MESSAGE
The MESSAGE statement defines a signal name and the text used to
format the associated message.

    MESSAGE identifier (language) "format string"
    
The identifier must be a valid JBasic name that is not already
a reserved word, function name, or statement name.  

The language code is the two-character language code used to
select messages based on the current user's preferred language.
The default is (EN) for English.  Other codes include (ES) for
Spanish or (FR) for French.  If the language code is omitted,
then (EN) is assumed.

The format string is the text string used to display the signal
when it is formatted for output as an error message.  If the 
signal allows an argument, it can be placed in the format string,
identified by the characters "[]" in the message text.

For example,

     MESSAGE RECTOOBIG "Record size of [] is too large."
.MID$
The MID$ pseudo-function is used on the left hand of an assignment 
operation to store character data into the middle of an existing string, 
without disturbing other characters in the string.

	NAME = "I AM BOB SMITH"
	MID$( name, 6, 8 ) = "TOM"
	PRINT NAME

The above sequence will print out "I AM TOM SMITH", because characters 6-8 
of the named string variable were replaced with the string expression "TOM".  
The string variable used in the MID$() pseudo-function must already exist;
you cannot create a new variable using the MID$() operation.

The position within the string is 1-based; that is, the first character is 
position 1, and the last character is at the position also returned by the 
LENGTH() function.  A runtime error is generated if the start position is 
less than 1, the end position is greater than the length of the string, or 
if the end position is less than the start position.

If the string value to be inserted is shortened than the required number of 
characters it is blank-padded.  If it is longer than the available space, 
the string is truncated such that only the left-most characters are used.
.MULTIPLY
The MULTIPLY statement multiples an existing variable by an expression.

    MULTIPLY X BY 3.5

This calculates the value of X * 3.5 and stores the result
back into the variable X, which must already exist.  This is
semantically identical to LET X = X * 3.5.

.MULTIUSER
Normally, JBasic runs on behalf of a single user - the user who invoked 
JBasic from a command line, or perhaps ran a program that uses JBasic as
its scripting language. In this mode (referred to as SINGLEUSER mode) there
are no special considerations for user identity, permissions, or control of
file access.  These are instead managed by the operating system on behalf 
of the user, as they are for any running program.

JBasic also supports a mode where multiple users are connected to the same
instance of JBasic. This is called MULTIUSER mode. In this mode, there is a
single JBasic program running, which accepts connections via a Telnet-style
communication protocol, and creates a thread for each incoming connection. 
Each thread has its own JBasic instance, but they are managed more like a 
tree of threads (see the documentation on CALL for information on threads) 
than as individual connections.

These individual users have a user identity that is not the identity they 
have on their connection computer but rather the identity they log in with
when connection to the MULTIUSER server. These identities are used to 
manage the location where the user is allowed to read and write files or 
save programs, and what permissions they have (including do they even have
permission to read files, for example).

This mode is intended to support/host a student environment where multiple
students may wish to use JBasic under the control of an instructor who 
places limits on their ability to interact with the hosting computer
that is running the actual JBasic server. This mode is not intended for
every-day use, because there are significant limits placed on the remote 
users who connect to a server.

Preparing for MultiUser Mode

To run a multiuser user, you need to decide what port the users will all 
connect on to make the initial contact with the server, and you must also
create a user database that describes the identity, permissions, and file
system areas that the users will have access to when connecting to your 
server. Finally you must prepare the directory areas for student use.

The port selection defaults to port number 6100. That is, this is the 
port number that students will use by default to connect to a JBasic 
server on your host computer. However, only one server at a time can use
any given port number, so if you have multiple servers (for example, one
server for each class) then each one must be assigned a unique port 
number. Additionally, these numbers must not collide with any other
well-known port numbers on your system. If in doubt, contact your system 
or network administrator for suggested port numbers or ranges to use. The 
global variable SYS$PORT must be defined on each server instance of JBasic
before the server is started with the SERVER START command.

User data entry can be done in one of two ways. You can create or edit a 
text file that contains the user data definitions, or you can use the 
SERVER command to create or modify each user identity record. The 
easiest way to do this is often to use the SERVER ADD command to create 
one or two records and then save the database to a text file that you can 
then edit (using the existing records as a template). You may also wish to
consider writing a JBasic program that can help you create the user data.

The server database text file is a file of XML data describing the logical
names and user definitions that the server is to use when running. The
SERVER DEFINE command creates logical names, and the SERVER ADD and
SERVER MODIFY commands are used to create or change attributes of the
users.  The SERVER SAVE command is used to store the server database
back to the XML-formatted file.

When students log into the server, they will probably need to have a place 
to read and write files as well as to save JBasic programs they write. 
Each student is typically given a different directory area in which to 
work. In the example database above, each user has a sub-directory in the 
/tmp/jbasic directory of the computer. Each user's file activity (both
loading and saving programs as well as files read or written by their user
programs) are automatically constrained to the home directory of the user.
This prevents users from being able to access each others files, or files
outside the defined area of the file system. Do not specify a home 
directory that is also used for any other purpose. For example, do not use
your own home directory as this will mean that your students can access 
(read and write or delete) your files. It is recommended that a sub-
directory of your computer's temporary space (/tmp or c:\temp, for 
example) be used for student file system space.

Controlling the Server

See the specific HELP entries for the SERVER and SHOW SERVER commands
for details on how to control the server.  These commands are used to 
manage the user database, start and stop the server, and display the 
status of the server and its users. In general, the intent is that the
instructor or other administrator starts JBasic, loads the user data, 
and starts the server mode on behalf of the students. As long as the
JBasic server is running, the students have access.

It should be noted that the user database exists in the memory of the 
server instance of JBasic. You can modify the user characteristics, but
you must save them to disk to persist them to be used in the future. See 
the SERVER LOAD and SERVER SAVE commands for more information.

.NEXT
The NEXT statement identifies the end of a FOR-NEXT loop
construction. See the help for FOR for more information.
.NEW
The NEW statement creates a new program with no statements
in it.  You enter new statements by entering commands that
are preceded with a line number.  Statements may be entered
in any order, bur are stored in line-number-order.

    NEW [kind] [name]

If you do not specify a kind of FUNCTION, VERB, or TEST,
then PROGRAM is assumed.

If you do not give the program a name, it will be given
a unique name.  This is the name that the program will 
be referenced by in a SHOW PROGRAMS listing or when you
wish to call the program from some other program.

The program is created with a declaration statement, a
few header comments, and a RETURN statement.  You can
use the RENUMBER command to change the line number
ordering in the program as you add new statements.

You can also create a program from a variable, if the
variable is a RECORD that contains a NAME field with the
name of the program, and a LINES field which is an array
of strings containing the program text lines.  Use the
syntax:

    NEW USING( v )
    
Where v is any expression that results in a suitable
RECORD definition. Note that the PROGRAM() function
will produce a record that can be used to recreate a
program.  Programs created this way are NOT marked as
new and needing to be saved if you wish to persist the
programs on disk or in a workspace.

.OLD
The OLD statement makes an existing program become the
current program.  The program name must exist as a
program in the stored program memory.  See the LOAD and
SAVE commands for information on how to bring programs
into and out of stored program memory from other
locations like a disk.

    OLD name

The existing program (if any) is not disturbed, but the
program named in the OLD statement becomes "current".
That means that a RUN command with no argument will run
that program, and a LIST command will list it.  Statements
can be stored in the program by entering them with a 
line number on the command line.

You can use OLD to access the program text for non-program
objects by including the type.

    OLD FUNCTION MIXEDCASE

This makes the function MIXEDCASE be the current program
object that can be modified or viewed (via LIST).  You
cannot access intrinsic functions this way, since they
do not have associated JBasic program text.
.ON
The ON statement declares a GOTO statement to be executed
in the event of an error being signaled.  The error could be
generated by the program code itself (see the SIGNAL statement)
or could be the result of an error in the program syntax or
execution signaled by JBasic.

    ON ERROR THEN GOTO ERROR_HANDLER

This will cause control to transfer to the label ERROR_HANDLER
when any error occurs.

    ON TOOBIG THEN GOTO FIX_UP

This will cause a GOTO to the routine FIX_UP to be executed if
the specific error TOOBIG is signaled.

An ON statement only applies to the program it is executed in.
For example, if PROGRAM FOO calls PROGRAM BAR using a CALL
statement, and PROGRAM BAR has an ON statement, then only
errors executed while in PROGRAM BAR will trigger the
GOTO statement.  When PROGRAM BAR executes a RETURN
statement, then the ON..THEN GOTO is discarded.  Each
PROGRAM may have it's own ON statements, so PROGRAM BAR
and PROGRAM FOO may each have an ON ERROR statement, and
each is executed when the error is signaled from within
the program that contains it.

An ON statement need only be executed one time in the
program to stay in effect for as long as that program 
is running regardless of whether an error is triggered
or not.

When an ON..THEN GOTO statement is executed, the system
variable SYS$STATUS can be used to determine the specific
nature of the error.  This is a record with these fields:

   CODE         A string containing the abbreviated error
                code, such as SYNTAX or TOOBIG.
                
   PARM         The argument to the error, if any.  This
                is the text supplied in a SIGNAL statement,
                or that was supplied internally in JBasic
                when an error occurred.  For example, if
                SYS$STATUS.CODE is "SYNTAX", then the field
                SYS$STATUS.PARM contains the detailed syntax
                error info.
   
   SUCCESS      A boolean that indicates if the error reflects
                a successfully or unsuccessful operation. This
                is typically used with EXECUTE .. RETURNS to
                check to see if the statement executed was
                successful.
                
.OPEN
The OPEN statement opens a file for use with a PRINT, LINE INPUT, or
INPUT statement.  You must specify the path name of the file, the
mode (INPUT or OUTPUT) and give an identifier used to reference this
file later.

    OPEN FILE "full-path-name" FOR mode AS identifier
    
Any of the three clauses FILE, FOR, or AS can appear in any order,
but all must  be specified.  The identifier is used to locate this
specific file later for statements that reference the file such as
a PRINT statement.

The 'mode' must be one of the following keywords:

    INPUT     The file must already exist and is opened for input.
    
    OUTPUT    The file is created if needed and is written to from
              the beginning of the file.
              
    APPEND    The file is created if it does not exist.  Writing
              begins at the end of the existing file if there is
              any existing content.
    
    BINARY    The file is created if it does not exist.  The file
              is written to with PUT statements, read with GET
              statements, and can be positioned to arbitrary byte
              positions in the file with the SEEK statement.
   
    DATABASE  The file is actually a connection to a JDBC driver
              to a database.  See the help on DATABASES for more
              information.
    
    PIPE      The filename is actually a command sent to the 
              native operating system.  The output of the command
              is returned as the file's contents.  A PIPE file
              type can be use for input and output, but be careful
              not to create a program that "deadlocks" because the
              pipe is waiting for input from your program while your
              program is waiting on output from the command process.
    
    SERVER SOCKET
    CLIENT SOCKET
              Sockets define network connections.  A SERVER SOCKET 
              has a filename which is actually the port number on
              the local host to listen for connections.  A CLIENT
              socket is a string of the form "hostname:port" where
              the hostname is the host IP address or name, and port
              is the port on that host where a server is listening.
              
              A SERVER SOCKET can be opened more than once as long
              as the file ref is unique (see the USING clause below
              for more info).  A CLIENT SOCKET can also be opened
              more than once as long as the server accepts multiple
              connections.  In both cases, the fileref variable
              contains a PORT and LOCALPORT number which describe
              the public port and the actual local socket port being
              used for the connection.
              
As an alternative to the AS file-ref clause, you can give a variable
name containing the name of the fileref, and specify it with the 
USING clause

    FR = "FILE_" || SEQNO++
    OPEN FILE "x.txt" FOR OUTPUT USING(FR)

In this example, assume that the first statement creates a string
value of "FILE_35" by incrementing the SEQNO variable to create 
a unique id. This is used by the OPEN statement to bind the file 
info to the fileref FILE_35.  In any other statement that references 
a file, the USING(FR) clause can be used instead of the specific file
reference.

For OUTPUT files, you can specific automatic column formatting by
adding the COLUMNS( w, n ) clause.  For example,

    OPEN FILE "x.txt" FOR OUTPUT AS X COLUMNS(25,3)

This means that each PRINT statement to the file that does not
include a newline will be aligned into 25-character-wide columns,
and every three columns a newline is automatically inserted.
If you then PRINT to the file with a newline, then the column
position is reset to the first column but formatting continues.
Note that if you do not use the trailing ";" to prevent a newline
character, then column formatting is not used.

In the column specification, if the width is less than zero, it
means that the column is right-justified.  If the width is greater
than zero, the column is left justified.

The identifier used to reference the file in subsequent operations
can be either an identifier such as EMPDATA or it can be an integer
value for compatibility with other dialects of BASIC.  When an 
integer is to be used, it must be preceded by a sharp sign (#).

	OPEN "x.data" for output as #3

In this case, the keyword FILE before the file name is also optional
for compatibility.

.PRINT

The PRINT command prints output to the console or a file.  The PRINT
statement accepts an optional FILE clause, followed by a list of one
or more expressions.  Each expression is printed in order, followed
by an end-of-line character.

    PRINT [ file identifier, ]  exp [, exp [, exp...]]

If the expressions are separated by a comma character "," then a
tab is printed between each character so they are spaced in columns.
If a semicolon ";" is used to separate the elements, then they are
printed directly next to one another.  You can include a trailing
comma or semicolon so that output does not go to a new line after
the PRINT statement output is generated.

If you wish to print to a file, then use a file identifier.  This
is the same identifier used in the OPEN statement to open the file.
This can be either the keyword FILE followed by a name, or a sharp
sign ("#") followed by an integer number to identify an open file.

You can use a trailing "=" on a variable reference in a PRINT
statement to cause the reference to be printed as well as the
value.  For example, the following code sample includes a "="
to request that the reference be printed:

   X = [1,2, {AGE:18}]
   N = 2
   PRINT X[N+1].AGE=
   
will result in the output being "X[3].AGE=18".  Expressions in 
the reference are resolved when the reference is printed.  You
cannot use this with arbitrary expressions such as "X+3=" or
with a function call.

.PRINT USING
The PRINT USING statement is an extension of the PRINT statement
that supports formatted text output.  A single format string
expression is given, followed by a list of comma-separated data
items that are used to fill values into the format string.  Unlike
the PRINT statement, all elements in the list must be separated
by commas.

    PRINT USING "Credit  ##.##     Net (###.##)", 3.5, -27.55
    
    Credit   3.50     Net ( 27.55)
    
The above example prints two values using a format string.  The 
format options are the same as those used in the FORMAT() function.
Text in the format string not part of the value format itself are
just printed.  There must be as many values in the variable list as
there are in the format string expression itself.

You can print the output to a file as well, similar to a standard
PRINT statement:

    PRINT #3, USING "000#.##", 1.3
    
Will result in the string "0001.30" being printed to the file
opened as #3.  If you wish to print to a file, then use a file 
identifier.  This must be the same identifier used in the OPEN 
statement to open the file.  This can be either the keyword 
FILE followed by a name, or a sharp sign ("#") followed by an 
integer number to identify an open file.

In a print using, you can use a trailing comma or semicolon
to prevent a newline from being added to the output if you wish
to print additional information on the same line of the output or
file.

.PROGRAM
The PROGRAM statement appears in a text file and identifies a block
of statements to be stored as an executable program in the JBasic
runtime.

    PROGRAM BOB

This defines a program that will be named BOB.  This must be the
first line of a new program that you create. In fact, the NEW command
will automatically create a first line containing a PROGRAM statement
for you.  If you modify the PROGRAM statement in the current program,
it effectively renames the current program.

A PROGRAM can have one or more arguments, which makes the program
a procedure suitable for use in a CALL statement.  For example,

    PROGRAM BOB( NAME, AGE )

This requires that two parameters be given in the matching CALL
statement that invokes the program:

    CALL BOB( "TOM", 48 )
    
A PROGRAM can explicitly declare the types of arguments by
putting a type name before the argument.  For example,

    PROGRAM FOO( DOUBLE V, INTEGER COUNT)
    
This declares a program whose first parameter will always
be converted to a double before being stored in the local
variable "V" in the program, and a second variable "COUNT"
which is coerced to an integer in the program.

You can also declare a default value for a parameter that
is not given.  Any parameter with default values must come
after all parameters without default values.  For example,

   PROGRAM FOO( DOUBLE V, INTEGER COUNT=10)

This version of the program FOO accepts one or two parameters.
If the second parameter is not given, then a value of 10 is
assumed.

Finally, you can specify variable untyped parameters by using
the ellipse:

   PROGRAM BAR( INTEGER COUNT, ... )

The program must have at least one parameter, which is the
integer COUNT.  It can accept any number of additional 
parameters.  These are available in the array $ARGS which
is a readonly local variable available to the executing
program.  The expression LENGTH($ARGS) will tell how many
arguments (including the integer COUNT) were supplied.

You can just use the ellipse with no named arguments to
indicate a program that takes zero or more arguments.  Such
a program can be invoked with the RUN command as well as
a CALL statement.

.PROTECT
The PROTECT command marks a program as "protected."  A program 
that is protected cannot be viewed by the end-user as source.
This means it cannot be selected as an OLD program, or listed 
with LIST or SHOW PROGRAM statements.

    PROTECT name
    
Where "name" is the fully qualified name of the program.  A verb
or function must include the correct prefix, such as

    PROTECT FUNCTION$ENCODE
    
This marks the user-written function ENCODE as protected.  

When a protected program is saved to a workspace, the code is not
stored as a JBasic program but is stored as compiled instructions. 
A program that is loaded from a workspace as a protected program 
remains protected.  Once a program is marked protected, it cannot 
be unprotected, and the source code for the program is lost.  
Always make a copy of any program you mark as protected!
.PUT
The PUT statement is used to write one or more values to a BINARY
file.  Data in a BINARY file is not stored as human-readable text,
but instead is stored in the native binary format for integers, 
floating point numbers, character strings, etc.  A BINARY file has
a current position (which can be determined using the GETPOS() 
function, or set using the SEEK statement).  This position defines 
where the next GET statement or PUT statement will read or write 
data.  Once data has been read, the pointer advances to the next 
unread byte of data.

The PUT statement has two forms.  The first form explicitly lists
the types and values to write to the file:

   PUT FILE <id>, <type> [(size)] <expr> [, <type> <expr>...]
     
The statement requires a FILE identifier, typically the identifier
created by the OPEN statement.  This is followed by a comma-separated
list of types and values, which can be variables or expressions. 
The size may be specified in parenthesis for strings that are fixed-
length string values.  The allowed types are:

     INTEGER         A 32-bit integer value
     DOUBLE          A 64-bit floating point value
     BOOLEAN         An 8 bit value that is either 0 or 1
     STRING          A string variable of fixed size
     VARYING         A string variable of varying size.
     UNICODE         A Unicode string variable of fixed size.
     
In the case of a string variable, the size of the value must be 
given in parenthesis after the keyword STRING, as in STRING(20). 
This indicates that the string takes up 20 characters of space 
in the file even if the actual string value is shorter.  See the 
help on the SEEK statement for more information on why this is 
important.

The same is true for a VARYING specification. The difference between
STRING and VARYING is that STRING data is of fixed length (the size
specified in the FORMAT) whereas VARYING data has an extra integer
length written to each buffer that tells how long the string really
is within the buffer.  Note that this means that VARYING should not
be used when attempting to read string data from binary files created
outside of JBasic.

When a value is given in the PUT statement, the type is converted 
to the data type specified in the PUT statement.  So

    PUT FILE BD, INTEGER 3.5
    
will result in an integer value of 3 being written to the file, since
the value "3.5" will be converted from a double precision floating 
point number to an integer value.

The second format of the PUT statement assumes that the contents of
the file (or a set of items to write to the file) are defined using
an ARRAY of RECORD values describing what to write.  For example,

    EMPREC = [ { TYPE:"STRING", SIZE:20, NAME:"EMPNAME" } ]
    EMPREC = EMPREC + { TYPE:"INTEGER", NAME:"EMPID" }

    PUT FILE EMPDATA, USING EMPREC

The value EMPREC must be an array, each element of which is a record
that describes the next item to write.  The record must have a field
named TYPE containing a string with the given type, and a field named
NAME containing the name of the variable from which to get the value
to be written.  A SIZE field may optionally be used to define fixed 
width string sizes.

The PUT...USING clause uses the contents of the array (EMPREC in the
above example) to write out values, a 20-character string and an
integer.  These must have already been stored in the variables EMPNAME 
and EMPID when the PUT statement is executed.

The EMPREC record can be used to read or write data (see the PUT 
statement for more information) as many times as needed.  So the above 
sample code defines the contents of the data in the file for an 
employee, and each GET..USING or PUT..USING statement uses the same 
data definition.

You can use the FIELD statement to create a record definition that
is associated with the BINARY file so you can just give a PUT statement
with no record definition, and the stored format is used.  See the
documentation on the FIELD statement for more information.

.QUIT
The QUIT statement terminates JBasic.  IF you have modified any of
the programs in stored memory, JBasic will prompt you to see if you
really mean to QUIT before issuing a SAVE command.

If you are in a shell (see the help on the SHELL command) then the
QUIT command exits the shell, rather than the entire JBasic session.
.RANDOMIZE
The RANDOMIZE statement is used to set the initial seed for the 
random number pseudo variable RND.  

	RANDOMIZE integer-expression
        ...or....
	RANDOMIZE TIMER

The first version requires an integer expression.  This value is used
to provide a starting value for the pseudo-random number function used
by the RND variable.  This function guarantees that for any given seed
value, the sequence of random numbers will be the same.  This allows you
to write code that assumes randomness, but test it with a predictable 
sequence of random numbers.

The second form uses a timer-based internal function to generate the seed
value.  This results in an unpredictable sequence of numbers from the RND
variable, and more closely approximates a true random number.

Note that in all cases, the RND function generates an artificial random 
number that is always in the range -32768 < x < 32767, and is always an 
integer value.  The RANDOM() function generates a dramatically more random
distribution of values, which also can be coerced into specific ranges 
using the function parameters.

In place of the RND variable, you can use the RNDVAL() function which 
returns the exact same information.

The RANDOMIZE statement and the RND pseudo-variable are provided for 
compatibility with programs written in GW-Basic or similar dialects 
supporting these operations.
.READ
The READ statement is used to access values defined in DATA statements
and store those values in variables that can be used in the running
program.

    READ X, Y
    
    DATA 3, "Tom"

   
The above statements reads two values and stores them in the variables
X and Y.  The values read are the next to items in a DATA statement
somewhere in the program.  The DATA statement does not have to be
executed, or located near the READ statement.  See the help on the
DATA statement for more information.

You can optionally specify a data type after any variable name, which
causes the data value to be converted to the given type before being
stored in the variable.  For example,

    READ SALARY AS DOUBLE, NAME AS STRING

This converts the next two values to a double and a string data type 
before storing in the variables SALARY and NAME.

.RECORDS
A record is a list of values.  The values can be of any type - they
can be numbers, strings, or  arrays.  Unlike an array where the
elements are always addressed by their position in the array,
a record identifies its members by the member name.  A record
can have as many members as you wish, but each must have a
unique member name.  Member names follow the same rules as
variable names.

In some cases the record can be referenced just by name (such 
as when assigning it to another variable).  You can also 
reference the individual elements of the record using the 
member name of the record.

    X = MY_DATA.AGE
    
This references the element of the record whose member name is AGE; 
the value in that array element is assigned to the variable X.  You 
can store items in a record the same way:

    MY_DATA.NAME = "Tony"

If the variable MY_DATA is not already an record, the previous 
value is discarded and the variable re-typed as a record. If 
you store a record element in a member that does not exist, the 
member is automatically added.

You can find out what the names of the members of a record are
by using the MEMBERS() function:

    N = MEMBERS( MY_NAMES )

This returns an array of strings.  Each element in the array
corresponds to a member name in the record.  You can use one
of these member names to get a value from a member indirectly
using the MEMBER() function.

    X = MEMBER(MY_DATA, "AGE")
    
This is the same as MY_DATA.AGE, but allows you to determine the
member name as part of your program logic.

If you print a record member, it prints just like any other
scalar value.  You can also print the entire record, as in:

    X.NAME = "Sue"
    X.AGE = 3
    PRINT X
    
The output is { AGE: 3, NAME: "Sue" }, which shows a record
(defined by the braces) with two items.  The members are
reported in alphabetical order regardless of the order in
which they were created.  You can define record constants
like this yourself, as in:

    PERSON = { NAME: "Tom", AGE: 35 }

This creates an array called PERSON with two members.  The first
member is PERSON.NAME and is a string "Tom". The second member 
is PERSON.AGE and is the number 35.

Records cannot be used in arithmetic operations.  However, the
members of a record can be used just like normal.

    X = PERSON.AGE + 5
    
Record members can be arrays or records themselves.  Additionally,
you can create arrays of records.

    FAMILY = [ { NAME: "Tom", AGE: 35 }, { NAME: "Sue", AGE: 3 }]
    X = FAMILY[1]
    Y = X.NAME

In this case, Y will have the value "Tom", since that is the NAME
member from the first record in the array. 
.RENUMBER
Programs created at the console always have line numbers, which
identify the sequence in which the statements are stored and
executed (see the help on PROGRAMS for more information).  The
line numbers are arbitrary positive integers.  Sometimes, it is
convenient to renumber them, particularly to make new room for
additional statements to be added between existing statements.

    RENUMBER [[FROM] start [[BY] increment]]
    
The optional starting line number identifies what the first
line number of the program should be.  The default is 100.
The optional increment indicates what the increment between
line numbers should be.  The default increment is 10.  The
keywords FROM and BY are optional.
.RESUME
The RESUME command resumes program execution under control of the
debugger.  See the HELP on the DEBUGGER for more information on how
to debug a program.  This command can only be executed when the
debugger is active.

    RESUME [RESET]
    
This causes the current program to resume execution of statements in
normal order.  Execution will continue until either the program
finishes or a breakpoint is hit.  You can add the optional RESET
keyword, which resets each breakpoint that has already been detected
so the next time the condition is true, a new breakpoint will be
triggered.

See the HELP on BREAK for more information on breakpoints.
.RETURN
The RETURN statement ends execution of a program or function.  It 
may specify a value to be returned to the caller of the function or
program. If there is no calling program, then control is returned 
to the user.

The RETURN statement is also used to return from an internal sub-
routine invoked with a GOSUB statement.
.REWIND
The REWIND statement is used to direct the next READ statement to 
begin with the first DATA statement in the program, even if that 
is not the next place to READ.

    DATA 101, 102, 103
    READ X, Y
    REWIND
    READ Z

In the above sequence, the value of Z will be 101, since the REWIND
tells JBasic to start with the first DATA element.  See the help on
READ and DATA for more information.

You can specify the line at which to rewind the next READ operation
by giving a line number or label after the REWIND verb.  For example,

    100  DATA 101, 102, 103
    110  DATA 201, 202, 203
    120  READ X, Y
    130  REWIND 110
    140  READ Z
    
The first two READ operations read the first DATA items.  The REWIND 
statement then indicates that the next READ will start at line 110.
This means that the READ Z operation will read the value 201 into the
variable Z.

The REWIND statement can also be used to reset a BINARY or an INPUT
file to the first byte of the file, using the FILE keyword or the
"#" file notation:

    REWIND FILE BD
    REWIND #3

If the file is a BINARY file, this is the same as using the SEEK 
statement to position to the first byte,

    SEEK FILE BD, 0
    
That is, the above two statements are identical in operation for a
BINARY file.  The REWIND FILE statement is provided for convenience.

In the case of an INPUT file, the REWIND FILE statement resets the
input to the start of the file.  This has no effect on a file that
is really connected to the user's TERMINAL.  In the case of a file
that is a physical file on disk, this causes the next INPUT or
LINE INPUT statement to read the first line of the file again.
.RUN
The RUN statement executes a stored PROGRAM.  By default, the current
program is run.  The current program is the last program RUN, or the
program identified by the last NEW or OLD statement.  Optionally
you can specify the name of an existing stored program to RUN.

    RUN
    
    RUN BENCHMARK

When a program is executed via a RUN command, the variable $MODE in
the local symbol table is set to "RUN".
.SAVE
The SAVE command saves either the current program to a disk file,
or saves the entire current workspace.

    SAVE "program name"

This version saves just the current program into a text file of the
given name.  There must be a current program; i.e. you must have
used OLD, NEW, or RUN to make a program in memory be the current
program.  

    SAVE WORKSPACE ["workspace name"]
    
This version of the command saves all programs currently in memory
that have been modified by the  user.  This includes any programs 
previously brought into memory with the LOAD command as well as any 
programs created or changed in this session.  The workspace contains
all such programs.

If a name is not given, then the default is "Workspace.jbasic" in
your home directory.  You can determine the home directory used
via PROPERTY("user.home") which corresponds to the Java property
of the same name.

You can save just the current program as an XML file that can be
loaded via the LOAD command or transmitted to another program as
an XML file.  

    SAVE XML "file.xml"
    
This saves the current program as "file.xml".  This command cannot
be placed in a running program; it can only be executed from the
console or via the JBasic run() method.

.SEEK
The SEEK statement is used to position a BINARY file to a specific
byte in the file.  A byte is the smallest natural unit of storage 
in the computer, and can hold a value in the range 0..255.  Multiple
bytes are used to store larger values, such as an INTEGER which takes
4 bytes, or a VARYING which takes a byte for each character in the
string plus 4 bytes to store the length.

The SEEK statement is used to indicate the byte position at which the
next GET or PUT statement will read or write data.  This position 
must be calculated by your program based on what your program knows 
about the information that it has stored in the file.

    SEEK FILE <id>, <position>

The id is the file identifier from the OPEN statement used to create
or access the binary file.  The position is any integer expression 
that is used to indicate the specific position in the file to use 
for the next GET or PUT.  A value of 0 is used to indicate the start
of the file.  Negative numbers are not permitted.  You can find out 
the current position of the file using the GETPOS(id) function with 
a given file ID.

You can also use a record definition (such as used in the PUT or GET
statements) to position to a given record by record number.  

    DIM EMPREC[2]
    EMPREC[1] = { NAME: "USERNAME", TYPE:"STRING", SIZE:30 }
    EMPREC[2] = { NAME: "ID", TYPE:"INTEGER" }
    
    SEEK FILE BD, USING EMPREC, 3

In this case, the record definition array EMPREC describes a record
with a 30-character string and an integer value.  The SEEK FILE 
statement uses this record definition to calculate the position of 
the 3rd record in the file.  When the USING clause is used to
calculate the record number, the records are 1-based.  That is, the
first record is at position 1, the second is at position 2, etc.
This is different than the first use of SEEK which uses absolute
byte positions in the file starting with zero.

You can also use the FIELD statement to associate a record
definition for the binary file.  When a FIELD is in effect, the
SEEK statement automatically uses this record definition just as
if it had been given in the USING clause.  See the documentation
on the FIELD statement for more information.

.SERVER
The SERVER command is used to manage the state of the multiuser 
JBasic mode.  Normally an instance of JBasic is run by a single user
from a command shell or invoked as an instance within another Java
program to support scripting.  However, you can enable a multiuser
mode in JBasic that allows users to telnet to a server and run in a
controlled "sand box" mode.  This is suitable for student learning
environments, etc.

The remainder of this help will describe the various SET SERVER command
functions.

    SERVER ADD USER "name" PASSWORD "password"
    SERVER DELETE USER "name"
    
    This will add a new user to the user database, with the given name
    and password.  The password is case sensitive but the name is not.
    The second command deletes a user from the database.
    
    SERVER GRANT USER "name" PERMISSION "permission-name"
    SERVER REVOKE USER "name" PERMISSION "permission-name"
    
    This command grants (gives) or revokes (removes) a privilege from
    a given user.  The privilege name ALL is reserved to mean that all
    privileges are granted to a given user.  NOTE: The ALL privilege
    should not be used except for special cases since it grants any
    current and future privileges without restriction.  Some of the
    privileges that a user may need are:
    
        DIR_IO         Ability to scan directories, e.g. FILES()
        FILE_IO        Ability to read and write files
        ASM            Ability to use the ASM statement
        THREADS        Ability to create or manage threads
        ADMIN_SERVER   Ability to administer the server state
        ADMIN_USER     Ability to administer user database
        SHELL          Ability to execute SYSTEM commands
    
    SERVER DEFINE name = expression
    
    This defines a logical name in the current session.  The name is a
    standard identifier such as WS, and must be followed by an equals
    sign and a string expression (which can be a string constant).  This
    defines the logical name to the given value.
    
    SERVER DELETE LOGICAL NAME name
    
    This removes the logical name definition for "name" from the current
    session.
    
    SERVER LOAD ["database-file"]
    SERVER SAVE ["database-file"]
    
    These commands load the user name database file into memory, or save
    the current database state back to a file. If the file name is not
    given, it assumes "JBasic-users.txt" and is stored in the home
    directory of the user who started JBasic.
    
    SERVER START [PORT=port-number] [LOGGING=log-level]
    SERVER STOP
    
    These command start and stop multiuser mode.  By default, the server
    listens for telnet connections on port 6100, but you can override that
    by setting the global variable SYS$PORT to a different number before
    starting the server.  Additionally, the port number can be given on
    the SERVER START command line as well.  When the server is stopped, 
    all currently logged in users are disconnected and their work is lost.
    By default, logging is set to level 1 where warnings and errors are 
    printed to the console.  By setting to level 2, informational 
    messages are also printed indicating what the server is doing.  Logging
    level 3 produces debug data.
    
    SERVER SHOW USERS
    
    This command displays the list of authorized users, their user account
    characteristics, and the last time they logged in to the current server.
    
    SERVER SHOW SESSIONS
    
    This lists the currently-logged in user sessions.  For each session, the
    session name (usually of the form JBASIC_xxx), the login information, and
    some summary runtime statistics.
    
    SERVER QUIT USER "name"
    
    This terminates a specific currently logged in user.  The user's work
    is lost and their session is immediately disconnected.
.SET
The SET command is used to set options that effect the runtime behavior
of JBasic.  You can use the SHOW OPTIONS command to display the current
settings.  To set an option, just name it.  To turn the option off, 
prefix it with NO. 

    SET OPTIMIZE         // Enable the optimizing compiler
    
    SET NOBUILTINS       // Disable in-line intrinsic functions
    
You can specify more than one option at a time by separating them by
commas:

    SET AUTOCOMMENT, PROMPT="BAS> "
    
This illustrates that some options (such as PROMPT) accept a value in
the command.

You can also use the SET command to set permissions.  These permissions
define what the program is allowed to do (access files, create threads,
manipulate Java objects, etc).  Permissions are set as part of a user
profile in multiuser mode, but can also be set for individual sessions
using the SET PERMISSION command:

    SET PERMISSION=( permission-list )

Where the permission-list is a comma-separate list of permission names.
The list of permissions can be viewed with the SHOW PERMISSION command.
If only one permission is to be set in the SET PERMISSION command, the
parenthesis are optional.  You can also specify ALL or NONE to set or
remove all permissions.  Use of the SET PERMISSION command requires the
ADMIN_USER privilege if running in a multiuser session.

.SHELL
The SHELL command creates a new instance of the JBasic session.  This
is similar to running a new copy of JBasic from another terminal session.
The new shell inherits the current program space from the environment
where the SHELL command was issued (this is the same as how a thread
is initialized) but operates in command line mode.

When you use the QUIT command to exit the shell, all the variables
and other information in that shell are discarded, and control returns
to the session where the SHELL command was issued.

This allows you to experiment with a program by creating a temporary
shell session to run it, and when you are done you can discard the
effect of the program by exiting the shell.
.SHOW
The SHOW command is used to display information about the current runtime 
state of JBasic.  This can include active symbol tables, open files, 
loaded  programs and functions, etc.  See the individual help items below 
for more information:

    SHOW FILES         Displays the list of currently open files
    SHOW FUNCTIONS     Displays the list of user-written functions
    SHOW LOCKS         Displays the list of locks used by threads
    SHOW MEMORY        Displays the current memory usage for JBasic
    SHOW MESSAGES      Displays the list of message codes and text
    SHOW OPTIONS       Displays the settings of various runtime options
    SHOW PROGRAMS      Displays the list of loaded programs
    SHOW SERVER        Displays the state of the multiuser server mode
    SHOW STATUS        Displays general runtime status of JBasic
    SHOW SYMBOLS       Displays the symbols and their values
    SHOW TESTS         Displays the built-in unit test programs
    SHOW VERBS         Displays user written command verbs    
    SHOW VERSION       Displays the current version of JBasic

.SHOW CALLS
The SHOW CALLS command is only useful when issued from the DBG prompt.
See the HELP on the DEBUGGER for more information on how to debug a
program.

    SHOW CALLS
    
This displays a list of the currently active calls in the running program.
If PROGRAM ABC calls PROGRAM FOO which invokes function BAR, then the
call output might look like

     1:  FUNCTION FUNC$BAR       150
     2:  CALL     FOO           1030
     3:  RUN      ABC            110
 
This shows that the CALL from ABC was made at line 110 of that program,
the invocation of the function in FOO was at line 1030 of that program,
and that the function BAR is currently about to execute line 150.
.SHOW FILES
This lists the currently open files.  There are always two entries
for the console (the default place where PRINT displays text and
INPUT gets text), as well as any files opened by an OPEN statement.

    SHOW FILES

.SHOW FUNCTIONS
This shows the function names for all built-in and user-written
functions.

    SHOW FUNCTIONS 

    
You can see a list of help entries for functions by entering
HELP FUNCTIONS.  When requesting help for a function, be sure
to include the () parenthesis characters.

    SHOW FUNCTION name
    
If you include the name of a function (that is implemented as
JBasic program code versus a built-in function) then the program
text of that function is listed. 

.SHOW MEMORY
Displays the current memory usage by the JBasic session.  This includes
the memory actively being used to store data, the free memory that is
available to JBasic but not currently in use, and the total memory use
for JBasic (the sum of the in-use and free memory).  The total memory
represents the storage allocated for current and future use by JBasic.

    SHOW MEMORY [COMPRESS]

If the optional COMPRESS keyword is used, then JBasic first scans memory
to free up storage that no longer is needed or that contains stale data,
so that the "in use" report most accurately reflects the current memory
requirements for JBasic.
.SHOW PROGRAMS
This lists the programs available in stored memory.  A program must be
in stored memory before it can be RUN or used in a CALL statement.  The
LOAD command is used to load a program into memory from disk.

    SHOW PROGRAMS
    SHOW PROGRAM name
    
The second form essentially is a LIST command for the named program;
it does not change or effect the current program.
.SHOW SERVER
This command displays the state of the multiuser server mode of JBasic.

    SHOW SERVER STATUS
    
    SHOW SERVER USERS
    
    SHOW SERVER SESSIONS
    
The first command displays the general state of the server.  The server
can be in SINGLE USER mode, which is the default for a JBasic program.
It can be in MULTI USER mode if the multiuser server has been started.
When in MULTI USER mode, the session is either the CONTROLLING SESSION
that started and manages the server, or it can be a REMOTE SESSION that
is a user who has logged in to the server.

The SHOW SERVER USERS and SHOW SERVER SESSIONS display the list of users
known to the server and the list of active sessions created by remote
logins by those users.

See the SET SERVER command for commands that manage the server state
and the user database.

   SHOW SERVER LOGICAL NAMES
   
This lists the logical names that are defined for the server session.
These are names that can be included in file paths to reference pre-
defined locations.  For example, "ws::myfile.jbasic"  references the
file "myfile.jbasic" that is located at the logical name location
defined by "ws".
.SHOW STATUS
This command displays general information about the current JBasic
session object.

    SHOW STATUS
    
If you type the SHOW command without a qualifier, then SHOW STATUS
is assumed.
.SHOW SYMBOLS
The SHOW SYMBOLS command is used to display the symbol table of
currently defined variables.  By default, the current symbol table
(for the console if in interactive mode, or the currently running
program) is displayed.  

    SHOW SYMBOLS
    
You can also display all the tables (the current one and it's
parent tables) with:

    SHOW SYMBOLS ALL

You can also indicate a specific table that you want to dump the
contents of:

    SHOW SYMBOLS GLOBAL      The table for SYS$ variables
    SHOW SYMBOLS CONSTANTS   The table for TRUE, INFINITY, etc.
    SHOW SYMBOLS LOCAL       Same as SHOW SYMBOL TABLE
    SHOW SYMBOLS PARENT      The parent of the local table
                                     
 
.SHOW VERBS
This displays the list of verbs (commands) that are implemented in
JBasic program code.  These verbs are executed just like any other
statement, but instead of running internally in the JBasic engine,
they cause a special JBasic program to run.

    SHOW VERBS

    SHOW VERB name
    
If you include the name of a function (that is implemented as
JBasic program code versus a built-in function) then the program
text of that function is listed.                                     
.SIGNAL
The SIGNAL command generates a runtime error.  This can be used in a
program to simulate an error, or to invoke an ON unit previously
defined with the ON statement.

    SIGNAL code [( argument )]
    
The "code" is the name of a predefined status code like SYNTAX, or
a user-defined message created with the MESSAGE statement.  If the
message has a substitution value used in formatting a message, you
can specify that after the signal code. 

For example:

    SIGNAL SYNTAX, "unexpected comma"
    SIGNAL ARRAY
    SIGNAL USING( BOB ), "unexpected data"
    
The last example uses the expression (in this case, a variable 
BOB) to define the code.  If BOB was equal to "SYNTAX", then
the first and third examples have similar output.
.SLEEP
The SLEEP command causes JBasic to pause execution of the current
program for a given amount of time.

     SLEEP number [ MILLISECONDS | SECONDS | MINUTES | HOURS ]

The number can be either an integer or floating point value or
expression.  The optional unit designation indicates how the
number is interpreted, can be be expressed in plural or singular
form.  If a unit is not given, the SECONDS is assumed.  So 

	 SLEEP 1
	 SLEEP 1 SECOND
	 SLEEP 1000 MILLISECONDS
	 SLEEP 1/60 MINUTE

All have the same effect of pausing the current program for one
second.
.SORT
The SORT statement is used to sort an array into ascending order.  
The array elements must all be of the same type - you cannot mix
strings and numbers.  Additionally, the array may only contain
scalar values (strings and numbers) and may not contain records
or other arrays.

    X[1] = "Tom"
    X[2] = "Debbie"
    X[3] = "Robert"
    X[4] = "Nancy"
    
    SORT X
    
    PRINT X
    
The above will result in a printout similar to

    [ "Debbie", "Nancy", "Robert", "Tom" ]

You can also use the SORT() function with an array name as the
parameter, and it will return a new array in sorted order. Using
the above array example,

    Y = SORT(X)
    
This would result in a new array called Y that is a sorted 
version of X.

You can also use the SORT statement to sort an array of records, and
specify the field in the record(s) to be used as the sort key value.

    X[1] = { NAME: "Bob", AGE: 45 }
    X[2] = { NAME: "Sue", AGE: 35 }
    X[3] = { NAME: "Dave", AGE: 36 }
    X[4] = { NAME: "Amy", AGE: 42 }
    
    SORT X BY NAME

The BY clause identifies a field name in the records to be sorted.  The
example above will result in the record with NAME:"Amy" being the first 
element in the array, and NAME:"Sue" being the last.  The field values 
must all be the same type (just like sorting a standard array) and all 
the records must have a field of the given name.
.STEP
The STEP command is used to control program execution in the debugger.
See the HELP on DEBUGGER to get more information on how to run a
program under control of the debugger.  The STEP command can
only be used when the debugger is active.

The STEP command has several formats, each of which are described
here.

	STEP [n]
	
This steps (executes) one or more statements in the program.  The value
n defines how many statements to execute.  If not specified, then one
statement is executed.  This is the same as just pressing return at
the DBG prompt without entering a command.

	STEP INTO

By default, when a program calls another program (as a CALL statement,
or a function call, or a verb) the debugger runs the called program
in its entirety as a single STEP operation.  However, STEP INTO can
be entered and if the next statement to execute invokes another program,
that program is executed under control of the debugger as well.  This
command only takes effect on the statement about to be executed.

	STEP RETURN

If a STEP INTO has been issued and the user is debugging a program
that was called by another program, it may be desirable to resume
execution at the caller's program again.  The STEP RETURN command
causes the program to run until the next RETURN statement, where
the debugger regains control.
.STRING
The STRING statement is used to declare one or more variables of
type STRING, and optionally give them an initial value.

	STRING var1 [= value1][, var2[=value2]...]

The verb is followed by one or or more variable names separated by
commas.  Any of the variables may optionally be followed by a value
expression, which is automatically converted to a STRING data type
before being stored in the variable.

.SUB
The SUB statement defines a local routine in the current program that
can be called with a CALL or function invocation.

   PROGRAM FOO
   X = DBL(22)
   PRINT "Result is "; X
   SUB DBL(VAL)
   Y = VAL * 2
   RETURN VAL

In this example, DBL is a local subroutine being used as a function. The
function invocation executes the SUB routine just as if it was a separate
FUNCTION.  However, only this program can call the SUB routine; it is not
visible to other programs.  Note that after the PRINT statement, the 
program will stop; you cannot execute a SUB statement.  There is an implicit
END statement before the definition of the SUB routine.  A program can
have as many SUB routines as it needs.  The SUB routine can define 
variable length argument lists, default values, or explicit types just
like a PROGRAM or FUNCTION statement; see the help for those topics for
more information.

.SUBTRACT
The SUBTRACT statement subtracts a value from an existing variable.

    SUBTRACT 3 FROM X

This calculates the value of X-3 and stores the result
back into the variable X, which must already exist.  This is
semantically identical to LET X = X - 3.0
.SYSTEM
The SYSTEM statement executes a single statement in the native command
line environment.  For Windows, this is a DOS emulation command.  For
Unix systems, it is a command in your current default shell.  For VMS,
it is a DCL command.

   SYSTEM expression

The command to be executed is defined by the expression, which can be 
any text expression.  It can be a simple quoted string or a more complex
string expression.  The system variable SYS$STATUS is set report the
status of the shell process executed.  The field SYS$STATUS.CODE will be
the return code "*SYSTEM", and the SYS$STATUS.PARM will be the numeric
return code from the executed command (normally "0" means success for 
all systems except VMS where any odd number means success).

Note that the command is broken up into a command verb and arguments
when run on a Unix or related system.  If any of the arguments have
blanks in them, then the command should be passed as a set of string
(or an array of strings) where the first one is the command and each
one after are the optional arguments.

   SYSTEM "ls", "my file.txt"

This passes the argument "my file.txt" to the "ls" command on Unix
even though there is a blank in the name; if it was passed as a single
command it would treat "my" and "file.txt" as separate arguments.
The syntax SYSTEM ["ls", "my file.txt"] or the use of any expression
that results in an array is the same as the comma-separated list.

If you need to capture the output of a shell command, consider using
a PIPE file type to handle the output.  For example, the following
code executes a command (to list contents of a directory) and captures
the output.  In this example, the output is printed - similar to the
behavior of the SYSTEM statement - but could be processed instead.
    
    OPEN PIPE "ls -l" AS #1
    DO WHILE NOT EOF(1)
       LINE INPUT #1, TEXT$
       PRINT TEXT$
    LOOP

Like the SYSTEM command, the PIPE command expression can be an array 
of strings which define the command and its arguments, as in

    OPEN PIPE ["ls", "-l", FN] AS #1
    
.TABLES
A TABLE is a special kind of two-dimensional array in JBasic used
to store data in a fashion similar to a database table.  The TABLE
is functionally most like an ARRAY of RECORDS where each RECORD 
must have the same members and data types.

You create a TABLE using the TABLE statement, which creates a new 
data value in the current symbol table.  The TABLE must have a name, 
and one or more members with a specific data type.

     TABLE EDATA AS INTEGER ID, STRING FIRST, STRING LAST

This creates a table of employee data containing an employee ID 
number and a first and last employee name.  You can add records to 
the table in two ways: as records or as arrays. 

     EDATA = EDATA + [101, "Bob", "Smith"]
     EDATA = EDATA + [LAST: "Jones", FIRST: "Dave", ID:102]

In the first example, an array is being added.  In this case, the 
array members must be in the same order as was declared in the TABLE
statement. In the second case, a record is being added and the member
names must exactly match the fields declared in the TABLE statement.
In both cases, the data will be converted to the data type declared 
in the TABLE statement.

You can access a TABLE row as an array subscript.  For example,

     EMP = EDATA[1]

This sets EMP to { FIRST: "BOB", ID:101, LAST: "Smith" } which is a
record describing the individual row.  You can of course reference 
a specific member using member notation:

     LAST_NAME = EDATA[2].LAST

which sets LAST_NAME to the string "Jones".

Because a TABLE is meant to be used similarly to database table, 
you can also join two tables together with a common member value.
Assume the above table EMPLOYEES already exists, and we create a 
new one with payroll data:

     TABLE PAY AS INTEGER ID, DOUBLE RATE
     PAY = PAY + [102, 10.50]
     PAY = PAY + [101,  7.25]

This creates a table with just an employee ID and a floating point
value used to describe a pay rate.  You might wish to join these 
items together to create a view of the data that matches pay rates 
to employees.  You can use the JOIN() function:

     D = JOIN( EDATA, PAY, "ID")

This creates a new table D which contains the fields ID, LAST, FIRST,
and RATE.  The rows from the PAY are matched to the rows from EDATA
using the field ID; when a row in one table has a matching row in the 
second table where the ID field is the same, a new row is created in 
the output table merging all the fields of both tables for that row.  
If there is no match, then no new row is created, so if there was an 
employee ID 103 in the EDATA data but not in the PAY data, then no 
row for that employee would exist in the new table D.

You can sort the data in a table using the SORT statement with a BY 
clause that describes the column to sort by.  You can also use the
SORT() function on a table, 

     D = SORT(D, "LAST")

This sorts the data based on the LAST name field.  You can also subset
the data with a WHERE() clause in an expression, which can follow any
table expression:


     H = D WHERE( RATE >= 10 )

This creates a new table that contains the rows of the table D where 
the RATE field is greater than or equal to 10.0.  Rows that do not
meet this criteria will not be included in the HIGH_PAID table.

You can combine these expressions together to create complex data 
operations such as

     H = SORT( JOIN( EDATA, PAY, "ID" ) WHERE( RATE >=10 ), "LAST" )

This creates a table merging the pay and employee data, selecting only
those with a pay rate greater than 10.00 and then sorting the result 
by the last name field.

You can select a subset of the columns of a table using the SELECT()
function, which accepts a table name and a list of column names:

     F = SELECT(H, "ID", "LAST")

An error is signaled if a field is named that does not exist.  The
result of the SELECT() function is a new table with just the named
columns.  You can use the WHERE operator as well, such as:

     F = SELECT( H WHERE(RATE>=10), "ID", "LAST")

This selects the ID and last name columns from the subset of rows
where the RATE is greater-than or equal-to 10.  The WHERE operator
can be put on the source table as shown above or applied to the
result of the SELECT, but it is more efficient to use WHERE on the
inner-most table of an operation to reduce the number of rows that
are copies/duplicated as part of the query expression.

When you PRINT an entire TABLE the table is formatted for readability
with column headings, etc.  If you are writing an entire table to a
disk file, you should use XML() format so the column definitions and
rows are properly encoded and can be reconstructed into a TABLE using
the XMLPARSE() function when the data is read from a file.

You can also use the INPUT ROW OF statement (an extension to the 
INPUT statement) to read a row of data from a file or the console.
.TEST
The TEST command invokes built-in unit tests that are used to validate the 
correct behavior of JBasic.  TEST is a built-in verb (implemented in the 
file "Library.jbasic") that scans the list of loaded programs for tests,
which always begin with the string "TEST$".  

    TEST ALL            Execute all tests
    TEST identifier     Execute only the named test
    TEST                Display a list of built-in unit tests

.TIME
The TIME statement takes another statement and executes it, and then 
prints the number of statements executed (if the statement is a RUN
or CALL) and the elapsed time.  

    TIME CALL BENCHMARK()

You can cause the TIME command to run the test statement multiple times
to get an average time by including an integer constant count in the
command

    TIME(100) CALL BENCHMARK()

This runs the statement 100 times, and reports both the total elapsed
time and the time for each iteration.  The iteration count cannot be
an expression; it must be a constant integer value.
.UNLOCK
The UNLOCK command is used to release locks, which are objects used
to protect critical regions of a JBasic program. Specify one or more
lock names in a list to be unlocked. 

 	UNLOCK COUNT_L, COUNT_Q
 	    or
 	UNLOCK ALL LOCKS

The first statement release two locks COUNT_L and COUNT_Q.  The locks
must exist and be held by the current thread or an error is reported.
The second example releases all locks held by the current thread
unconditionally.

Note that you cannot UNLOCK a lock that you didn't lock.  If you LOCK
the same named lock more than once, you must unlock it the same number
of times before it is available for another process to use.  If a
thread exits while it still holds a LOCK then that lock is released.

You can specify USING(string-expression) for the lock name if the
name is determined at runtime. The USING() expression must be a string
that resolves to a valid lock name.  The USING() can also resolve to
an array of strings which describes a list of items to unlock.  It is
an error if the expression value is anything other than a string or
array of strings.

See the help on the LOCK statement for examples of how to use locks
in a JBasic program running with threads.

.UNTIL
The UNTIL statement defines the end of a DO-UNTIL block, and contains
the expression that would end the loop.  See the help on the DO
command for more information.

.WHILE
The WHILE statement defines the end of a DO-WHILE block, and contains
the expression that would end the loop.  See the help on the DO
command for more information.

.VARIABLES
Nearly all programming languages have the concept of variables, which are
ways of identifying storage that can be read, written, displayed, etc.

In JBasic, variables must be named with an identifier, which can be made
up from letters, numbers, or the "_", "#", "!" and "$" characters.  The 
first character cannot be a number.  Variable names are not case-
sensitive; there is no difference between the name "x" and the name "X".

Here are examples of valid variable names:

    X            SYS$PROGRAMS
    PLAN9        MY_DATA$

A variable can hold a single value (referred to as a "scalar" value),
or it may hold a list of values in the form of an array or record.
Scalar values can be numbers, strings, or true/false values.  An
array or record is a special variable that contains a list of scalar
values.  See the HELP entry for ARRAYS or RECORDS for more information
about these types.

You can print, assign, input, etc. a variable without caring what it's
type is.  You cannot perform all mathematical operations on all data
types; it makes no sense to divide a string by number, for example.
JBasic will automatically convert data types if possible, so the
expression "10"/5 results in the number 2.

By default, a variable can contain data of any type.  That is, the
variable X can contain an integer, and later be used to hold a string,
and later a record type.  This is called "dynamic types" and is the
default way that JBasic works.  

However, some older versions of BASIC assume that the name of the
variable indicates the type of data that is stored in it, and further
assumes that type conversions will be done as needed.  This can be
set with the SET STATIC_TYPES command.  (Use the SET NOSTATIC_TYPES
to return to the default setting.)

Here are the default type codes applied to variables when STATIC_TYPES
are enabled:

    COUNT#      The "#" character indicates an integer variable
    NAME$       The "$" character indicates a string variable
    IN_USE!     The "!" character indicates a boolean variable
    EMPL$$      The "$$" characters indicate a record

A name that does not have a character at the end is assumed to be
a floating point number.  Note that you can use the DIM statement
to specify a type for a variable regardless of it's name:

    DIM MYNAME AS STRING

In this case, MYNAME will be a string variable even though it does not
have "$" at the end of the variable name.
.VERB
The VERB statement appears in a text file and identifies a block
of statements to be stored as code to be executed when the
corresponding command (a "verb") is given in JBasic.  This is
very similar to a PROGRAM except it will be automatically run
by JBasic when the verb is given as a statement.

    VERB SUPPLY

This defines a verb  that will be named SUPPLY.  This must be the
first line of a new program that you create. In fact, the NEW command
will automatically create a first line containing a PROGRAM statement
for you.  You will need to modify this statement to be a VERB
statement if you are writing a statement extension to JBasic.

A VERB has access to the rest of the statement text that follows
it.  The rest of the line is parsed into individual tokens, and 
these are stored in the ARG$LIST[] array that is passed to the 
program.  So if you entered the statement

    SUPPLY DEPOT 3

The element ARG$LIST[1] would contain "DEPOT" and ARG$LIST[2]
would contain "3".  Note that the arguments are always strings,
but you can use them as numbers if you know they contain only
numeric values.  So ARG$LIST[2] * 2 would be equal to 6 in
the above example.
.XML
XML refers to Extensible Markup Language, and is an industry
standard way of expressing information that can be shared between
programs, computers, and networks with great accuracy regardless
of the computer systems, languages, etc. involved.  JBasic can
express any data value as XML, and can parse XML created to
describe JBasic values.

Here is the most basic structure if an XML Value definition:

	<?xml version="1.0" encoding="UTF-8"?>
	<JBasicValue>
	  <Integer>3</Integer>
	</JBasicValue>

In this case, it is representing the integer value 3.  The first
part is a comment that identifies this as an XML string.  The
second part is common to all JBasic XML strings, and indicates
that this is a JBasicValue, which means a data representation for
JBasic.  This is followed by the actual data type and value, and
then the matching closing tag for the JBasicValue.  This same
format applies to all the scalar data types:

	<Boolean>true</Boolean>
	<Double>3.553</Double>
	<String>"This is \"Test\""</String>

Note that the string is in quotation marks, and contains any
characters that cannot be represented in a string as escaped
characters, such as the \" which represents a quotation mark.

Arrays are stored as a list of values.  For example, this is
an array of integer values, containing [101, 102, 103]:

	<?xml version="1.0" encoding="UTF-8"?>
	<JBasicValue>
	  <Array>
	    <Integer>101</Integer>
	    <Integer>102</Integer>
	    <Integer>103</Integer>
	  </Array>
	</JBasicValue>


A RECORD type is a little more complicated because it uses
the field names as the tags around each value.  Here is the
XML representation of a simple record {AGE:14, NAME:"Susan"}

	<?xml version="1.0" encoding="UTF-8"?>
	<JBasicValue>
	  <Record>
	    <AGE>
	      <Integer>14</Integer>
	    </AGE>
	    <NAME>
	      <String>"Susan"</String>
	    </NAME>
	  </Record>
	</JBasicValue>

Here, tag is followed by each field name as a tag that itself
contains a data item.

Finally, you can combine types just as you can in JBasic
to create compound data types. Here is an array of records
each describing a person:

	<?xml version="1.0" encoding="UTF-8"?>
	<JBasicValue>
	  <Array>
	    <Record>
	      <AGE>
	        <Integer>14</Integer>
	      </AGE>
	      <NAME>
	        <String>"Susan"</String>
	      </NAME>
	    </Record>
	    <Record>
	      <AGE>
	        <Integer>10</Integer>
	      </AGE>
	      <NAME>
	        <String>"Danny"</String>
	      </NAME>
	    </Record>
	  </Array>
	</JBasicValue>


You can generate valid XML for any given value by using the XML()
function, which returns a string.  You can parse valid XML that
describes a JBasicValue object using the XMLPARSE() function.  See
the individual help entries for these items for more information.

Additionally, you can save a program as an XML definition by using
the SAVE XML command.  When you load a program file, JBasic checks
to see if the file is an XML definition of a program and parses the
file accordingly.
.$MODE
This is a reserved variable created by JBasic to describe the current
execution mode.  The string value tells the currently-executing 
program how it was invoked. Additionally, the variable $THIS contains
the name of the current program, and $PARENT tells what program was
active when the current program was invoked or called.  Additionally,
the array $ARGS will always contain the argument list to the current
program as passed in by the caller.

 +----------+---------------------------------------------------+
 |   Value  | Description                                       |
 +----------+---------------------------------------------------+
 |   CALL   | The current program was invoked with the CALL     |
 |          | statement.  There may be arguments, and a return  |
 |          | value may be given.                               |
 +----------+---------------------------------------------------+
 | FUNCTION | The current program was invoked as a function in  |
 |          | an expression.  There may be arguments, and a     |
 |          | return value must be given.                       |
 +----------+---------------------------------------------------+
 |   INIT   | The current program was invoked as part of the    |
 |          | initialization of JBasic before the first user    |
 |          | command input or program execution.               |
 +----------+---------------------------------------------------+
 |  METHOD  | The current program was invoked as a method for   |
 |          | an object.  There may be arguments, and a return  |
 |          | value may be given.  The local variable  THIS     |
 |          | identifies the object being manipulated.          |
 +----------+---------------------------------------------------+
 |   RUN    | The current program was executed with the RUN     |
 |          | command. It cannot return a value and has no      |
 |          | arguments in this mode.                           |
 +----------+---------------------------------------------------+
 |   VERB   | The current program is a user-written verb, run   |
 |          | because the verb was given as a command.          |
 +----------+---------------------------------------------------+
       
.$PREFERENCES
This is a reserved program name.  If a program of this name is found
either in the predefined library or in the default WORKSPACE then it
is loaded and run as part of startup.  Place any default settings
you wish in this file to be executed each time you run JBasic from
a shell.

Note that this program is not run when JBasic is used as an embedded
class in another Java program, since it is assumed that the embedding
program will have its own preference management mechanisms.

.. Function definitions start here.  Functions start with a ":" instead
.. of a "." character.
:ABS ( )
val = ABS(val)

Returns the absolute (positive) value of the function argument.
:ARCCOS ( )
val = ARCCOS( val )

Returns the arc (inverse) cosine of the argument.
:ARCSIN ( )
val = ARCSIN( val )

Returns the arc (inverse) sine of the argument.
:ARCTAN ( )
val = ARCTAN( val )

Returns the arc (inverse) tangent of the argument.
:ARRAY ( )
Returns an array constructed from all the arguments.  This is
essentially the same as creating an array constant.

     x = ARRAY( 1, 2, "Tom", 3.3 )
     
     y = [ 1, 2, "Tom", 3.3 ]
     
These statements have the same effect.
:ARRAYTOSTR ( )
sval = ARRAYTOSTR( array )

Returns an string, where each element of the array is has been
concatenated into the string.  The string length will be the
sum of the length of each array element.
:ASCII ( )
ival = ASCII( string )

Returns an integer containing the ASCII or UNICODE value of the
first character of the given string.  IF the string is empty,
the result is zero.
:BASENAME ( )
sval = BASENAME( file-name-expression )

This parses the file name in the string expression and returns
the base name; that is, the file name without the path or file
extension information.  For example, BASENAME("/users/tom/bob.txt")
would return the string "bob".

No attempt is made to determine if the file actually exists or is
a valid name.
:BINARY ( )
ival = BINARY( string-expression )
sval = BINARY( integer-expression)

In the first example, the function converts a string containing
a binary value such as "1101" into an integer containing the
decimal value of 13.  

In the second example, the integer decimal value is converted
to a string containing the binary representation, so a parameter
of 65 becomes the string "01000001".
:BOOLEAN ( )
bval = BOOLEAN( any-expression )

This converts the argument to a boolean value, by applying all
possible conversion operations.  For example, integer and
double precision numbers convert to true if they are non-zero,
and false if they are zero.  For strings, the values "true",
"yes", and "1" all evaluate to true, and any other string
is considered to convert to "false".
:BYNAME ( )
rval = BYNAME( string-buffer, varname [, varname ...])
rval = BYNAME( string-buffer )

This function implements the INPUT BY NAME feature as a runtime
function.  The string-buffer argument is a string expression 
containing one or more variable assignments, such as "X=3,B=5".

The result of the function is a record containing the members
from the input variable list and the associated values.  The
BYNAME() function parses the input and creates the output record
or signals a SYNTAX error if the input cannot be parsed.

In the first use, the remaining arguments are explicit variable
names expressed as strings.  In this case, the input is searched
for the given input variables and the resulting record will only
contain those values.  

In the second use where no variable list is given, the resulting
record contains all variables in the input string that were
found during parsing.

    BYNAME("ID=10, AGE=49, SIZE=3.5", "AGE", "NAME", "ID")
    
Would result in { AGE:49, ID:10 } as the result.  The variable
NAME was not found in the string buffer and is not given a value.
The variable SIZE is not processed because it's not in the list
of expected names.

    BYNAME("ID=10, AGE=49, SIZE=3.5")

Would result in { AGE:49, ID:10, SIZE:3.5 } since there is no
explicit list of variable names so all successfully parsed
values in the input buffer are represented in the resulting
record.

:BYTECODE ( )
rval = BYTECODE("program")

For a given program name expressed as a string, return a RECORD
data type containing an encoding of the bytecode string.  This
can be stored in any fashion and then later converted back to a
runnable program with a NEW USING(rval) operation that uses the
contents of the record to create a protected instance of the
original program.
:CALL ( )
val = CALL( function-name [, arg1 [, arg2..]])

This generates a call to a function, expressed as a string in
the first argument, which is required.  The remaining arguments
are passed to the function itself. This allows indirect function
calls in JBasic.  For example, X = CALL( "PI", 3 ) calls the 
function PI(3) and sets the result into X. 

:CEILING( )
dval = CEILING( numeric-expression )

The expression is converted to a double and the arithmetic
ceiling is calculated; that is, the next largest whole number
value is returned as a double.  So CEILING(3.3) returns 4.0.

:CHARACTER ( )
sval = CHARACTER( integer-expression )

Returns a string containing a single character, which is the
character encoded value of the integer-expression.  For example,
the integer value 65 translates in UNICODE to the single
character string "A".
:CIPHER ( )
sval = CIPHER( string-data [, password ])

This uses the Java encryption features to create an encrypted
string from an unencrypted string.  The string-data is passed 
and the encrypted value is returned.  Note that the encrypted
string value will always be longer (sometimes as much as four
times longer) than the unencrypted string.

If no password is given, then an internal password is used on
your behalf.  However, this means every instance of JBasic
can decrypt the value using DECIPHER().  Instead you should 
always use the password argument to specify a string value
used as part of the encryption key.  This same password must
be given to DECIPHER() to decode the value.
:CLASS ( )
objval = CLASS( string-expression )

Returns a Java wrapper object for a Java class of the given 
name.  The resulting object can be used in the NEW() function
to define the class of objects to be created.
:CLASSOF ( )
sval = CLASSOF( objval )

Given a Java object created by NEW(), returns a string with the
Java class name.  IF the objval is instead a native JBasic data
type, the corresponding Java type is returned ("int", "String"),
etc.
:COMPILE ( )
bc = COMPILE( statement-text )

A JBasic statement expressed as a string is passed as the 
argument.  The statement is compiled into bytecode and
returned as an array of bytecodes. This can be executed
later with the ASM USING() statement which accepts an array
of strings and executes the associated bytecode.
:COS ( )
rval = cos( v )

Return the trigonometric cosine of the value passed in as a
floating point result.
:CSV ( )
sval = CSV( any-argument-list )

Returns a string of the argument list items formatted as text
and separated by a delimiter. The default delimiter is a comma,
resulting in a comma-separated-values list.  The arguments are
formatted recursively, so passing an array or record results in
the members of the array or record (in alphabetical key order)
being added to the list.  You can set the delimiter by setting
the SYS$CSVDELIMITER variable if you want a delimiter other 
than a comma, such as "\t" for a TAB character.
:DATE ( )
val = DATE( [date-value [,format-string]])

In it's most basic format, DATE() returns a string containing 
the formatted value of the current date and time.  The first
optional parameter is the date value, and the second optional
parameter is a format specification.

If the date is given as a floating point number, it must be
the number of milliseconds since the start of the epoch, and
that date is formatted as the date value.  If a string is 
given as the first argument, then the string is parsed to 
extract a valid date value from the string and returned as 
a double that contains the date value encoded in milliseconds.

The second argument is the format pattern used to format or
parse the data.  This is a string containing one or more
date elements.  Values not in this list are processed
literally; i.e. a "/" character is just copied to the output
string when the format is "MM/dd/yyyy", for example.

Code Date or Time           Examples
G    Era designator         AD
y    Year                   1996; 96
M    Month in year          July; Jul; 07
w    Week in year           27
W    Week in month          2
D    Day in year            189
d    Day in month           10
F    Day of week in month   2
E    Day in week            Tuesday; Tue
a    Am/pm marker           PM
H    Hour in day (0-23)     0
k    Hour in day (1-24)     24
K    Hour in am/pm (0-11)   0
h    Hour in am/pm (1-12)   12
m    Minute in hour         30
s    Second in minute       55
S    Millisecond            978
z    Time zone              PST; GMT-08:00
Z    Time zone              -0800

If the second argument with the formatting pattern is not given,
the default is "EEE, d MMM yyyy HH:mm:ss Z" which results in 
output like "Sun, 28 Sep 2008 20:05:34 -0400".

If an invalid pattern is given, or if the first parameter is
a string to be parsed that is an invalid format, then an error
is signaled.

You can pass a date value of 0, it is treated the same as the
current time, so DATE(0) returns a formatted string of the
current time. Similarly, a value of "TODAY" is treated as the
current time in formatted fashion, and the result is the numeric
time value in milliseconds.

Also, you can pass a format string of "*" with a numeric time
value and the result is a record containing each of the parts of
the time value.  So DATE(0,"*") returns all the information about
the current time. The resulting record contains the following
fields:

+-------------------------+------------------------------------+
|  Field                  | Description/Notes                  |
+-------------------------+------------------------------------+
|  AM_PM                  | 0 for a.m., 1 for p.m.             |
+-------------------------+------------------------------------+
|  DATE                   |                                    |
+-------------------------+------------------------------------+
|  DAY_OF_MONTH           |                                    |
+-------------------------+------------------------------------+
|  DAY_OF_WEEK            | 0-Sunday, 1-Monday, etc.           |
+-------------------------+------------------------------------+
|  DAY_OF_WEEK_IN_MONTH   |                                    |
+-------------------------+------------------------------------+
|  DAY_OF_YEAR            |                                    |
+-------------------------+------------------------------------+
|  DST_OFFSET             | Msecs, 3600000 is one hour         |
+-------------------------+------------------------------------+
|  ERA                    |                                    |
+-------------------------+------------------------------------+
|  HOUR                   |                                    |
+-------------------------+------------------------------------+
|  HOUR_OF_DAY            |                                    |
+-------------------------+------------------------------------+
|  MILLISECOND            |                                    |
+-------------------------+------------------------------------+
|  MINUTE                 |                                    |
+-------------------------+------------------------------------+
|  MONTH                  |                                    |
+-------------------------+------------------------------------+
|  SECOND                 |                                    |
+-------------------------+------------------------------------+
|  WEEK_OF_MONTH          |                                    |
+-------------------------+------------------------------------+
|  WEEK_OF_YEAR           |                                    |
+-------------------------+------------------------------------+
|  YEAR                   |                                    |
+-------------------------+------------------------------------+
|  ZONE_OFFSET            | Msecs from GMT, -18000000 is EST   |
+-------------------------+------------------------------------+

:DECIMAL ( )
ival = DECIMAL( string-value, radix )

This converts a string containing a number in a given radix (base)
into a decimal integer.  For example, DECIMAL("10101", 2) will
convert the base-2 (binary) number 10101 into the decimal value 21.
Any base between 2 and 36 may be used for this conversion.  See
the RADIX function for the reverse operation of converting any
decimal number to an arbitrary radix.

dval = DECIMAL( number-value [, scale])

The DECIMAL function can also be used to convert a numeric value
to a DECIMAL data type (a fixed precision value).  The first parameter
can be an integer, double, or boolean value, or another DECIMAL
value.  The scale is optional, and if not specified defaults to 
zero.  This indicates the number of decimal places to the right
of the decimal point that can be represented in the value.  For
example, DECIMAL(10./3., 4) results in 3.3333 with four digits of
precision after the decimal point.

:DECIPHER ( )
sval = DECIPHER( string-data [, password ])

This uses the Java encryption features to convert an encrypted
string to an unencrypted string.  The string-data is passed 
and the plain-text value is returned.  Note that the resulting
string value will always be shorter (sometimes as much as four
times shorter) than the encrypted string.

If no password is given, then an internal password is used on
your behalf.  However, only works if no password was given when
CIPHER() was used to create the encrypted data.  You should 
always use the password argument to specify a string value
used as part of the encryption key.  This same password must
be given to CIPHER() to encode the value.
:DOUBLE ( )
dval = DOUBLE( any-value )

This converts the argument to a double-precision floating point
value.  If the value cannot be converted (for example, a RECORD
or ARRAY data type, or a string with invalid syntax) then the
result is a NaN, a "not-a-number" value.
:EOD ( )
bval = EOD()

Returns a boolean value indicating if there is more DATA that can
be used to satisfy a READ statement.  If the value is true, then
it means that end-of-data has been reached, and the next READ will
access the first DATA item again.  If the value is false, then 
there is still at least one more DATA item to read before starting
over.  See the help on DATA and READ for more information.
:EOF ( )

bval = EOF( file-identifier )

Returns a boolean expression indicating if the named file (as given
by the file identifier from the OPEN statement) is positioned at
the end-of-file or not.  If the function returns false, then it is
possible to read more data from the file without error.
:EXISTS ( )

bval = EXISTS( file-name-string )

Returns a boolean value to indicate if a file exists or not, as
defined by a string expression containing it's name.
:EXP ( )
dval = EXP( x  )

This performs a mathematical exponentiation function, raising the
value 'e' to the power of X and returning the result as a double
value.
:EXPRESSION ( )

value = EXPRESSION( string )

Returns the results of evaluating the expression in the string.
For example, EXPRESSION("3+5") returns the value 8.  The expression
can be a string or numeric expression, and reference any active
variable.  The result type is based on the expression type.
:EXTENSION ( )
sval = EXTENSION( file-name-expression )

This parses the file name in the string expression and returns
the extension; that is, the part of the file name without the 
following the final extension separator character, including
the separator itself.  For example, BASENAME("/users/tom/bob.txt")
would return the string ".txt".

No attempt is made to determine if the file actually exists or is
a valid name.
:FILEPARSE ( )
rval = FILEPARSE( file-name-string )

Parse a string containing a file name, and returns a record with
fields for PATH, NAME, and EXTENSION elements of the file name.
For example, the string "/Users/tom/myprogram.jbasic" would result
in the record

   { EXTENSION:".jbasic", NAME:"myprogram", PATH:"/Users/tom/"}
:FILETYPE ( )

array = FILETYPE( filename-string )

Returns an record describing the file indicated by the
string parameter.  The array will be empty if the file 
name is invalid or references a file that does not exist.

The record has the following fields:
    PATH         The directory path of the file
    NAME         The name of the file itself
    READ         The file can be opened for reading?
    WRITE        The file can be opened for writing?
    HIDDEN       The file is hidden?
    FILE         The file is a file object?
    DIRECTORY    The file is a directory object?
    
An example record might look like

{ PATH: "/Users/tom", NAME: "jbasic", READ: true, 
    WRITE: false, DIRECTORY:true, FILE:false }

This indicates a that "jbasic" is a directory, can be
read but not written, and is not hidden.

Note that FILETYPES(path) returns an array of the same kind
of information that FILETYPE(file) returns.  FILETYPE()
returns the information about a single file; FILETYPES()
returns the information about all files in a directory.
:FILETYPES ( )

array = FILETYPES( path )

Returns an array describing the files found in the file system
path described by the string parameter.  The array will be
empty if the path is invalid or if the directory has no files.

The resulting array has an record in each element, of the
same kind of information as the FILETYPE() function.

Note that FILETYPES(path) returns an array of the same kind
of information that FILETYPE(file) returns.  FILETYPE()
returns the information about a single file; FILETYPES()
returns the information about all files in a directory.
:FLOOR ( )
dval = FLOOR( arithmetic-expression )

The expression is evaluated and converted to a double
value.  The arithmetic floor is calculated; that is, the
whole number component of the expression.  FLOOR( 3.8 )
returns the value 3.0, for example.
:FORMAT ( )

sval = FORMAT( expression, format-string )

The result of the expression is formatted using the format
string.  The format string indicates how the data (which
must be numeric) will appear by using sequences of special
characters to define how each character of the output will
appear.

The format characters are:

    #       Represents a digit.  If left of a decimal point,
            this will be blank if there is no digit in the
            corresponding position.  If right of the decimal
            point, this will be zero if there is no
            corresponding digit.
            
    0       Represents a digit.  If left of the decimal point,
            this will be a 0 if there is no digit in the
            corresponding position in the number to be formatted.
            This implements leading zeroes.  It is the same
            as "#" to the right of the decimal point.
            
    .       Indicates where the decimal point must be.
    
    $       Indicates a dollar-sign character is to appear
            at this position, if there is only one of them.
            If there are multiple $'s in a row, they indicate
            a floating $ that appears anywhere a $ does that
            is before the start of the non-blank string.
            
    ()      When parenthesis are included in the format, they
            representing accounting notation for negative
            numbers.  A negative number has the ( and )
            characters as the position given in the string.
            A positive number uses blanks for these positions.
            
Here are some examples:

    format( 3.5, "###.##")              3.50
    format( 3.5, "000.##")            003.50
    format( 3.5, "$$$.##")             $3.50
    format( -3.5, "(##.##)")         ( 3.50)
    format( 6, "0000")                  0006
    format( 22, "###")                    22

:GETBITS ( )
ival = GETBITS( sval, start, len )

Given a buffer stored in a string, extract an integer value from the
buffer given a starting bit position and length.  The position maps
the entire buffer into a single long string of bits.  So bit position
zero is the first available position, and is stored in the highest-
bit position of the first byte.  The length can be any value between
1 and 32. The function result is the integer value expressed as the
given bit string from the buffer. 

For example, GETBITS( "AB", 0, 8) returns the integer in the first
8 bits of the buffer, and returns the integer 65. As another
example,  GETBITS( "AB", 4, 4) returns the integer 1 which is 
extracted from the 4-8th bit positions in the buffer.

:GETPOS ( )
ival = GETPOS( fileid )

Returns an integer value indicating the current file position of the
given BINARY file.  If the file identifier is not valid or does not
reference a BINARY file, then -1 is returned.  A value of zero is
returned if the file is positioned at the start of the file, or an
integer indicating how many bytes into the file the next GET or PUT
will start at is returned.
:HEXADECIMAL ( )
ival = HEXADECIMAL( string-expression )
sval = HEXADECIMAL( integer-expression)

In the first example, the function converts a string containing
a hexadecimal value such as "0C" into an integer containing the
decimal value of 12.  

In the second example, the integer decimal value is converted
to a string containing the hex representation, so a parameter
of 65 becomes the string "40".
:INTEGER ( )
i = INTEGER( any )

Converts any data type to an integer, if possible, and returns
the result.
:ISOBJECT ( )
bval = ISOBJECT( variable )

Returns TRUE if the parameter is an object variable, else returns
FALSE. If the return value is TRUE, then you can use the OBJECT()
function to get information about the object variable.

:LEFT ( )
sval = LEFT( string, count )
aval = LEFT( array, count )

Returns a string containing the 'count' left-most characters of
the string.  If the count is less than 1 then an empty string is
returned.

In the second example, the parameter is an array, and the function
returns the first 'count' elements of the array.  For example, the
expression LEFT([ "T", 3, -5.8], 2 ) returns the result ["T", 3]
:LENGTH ( )
ival = LENGTH( any )

If the argument is a string, returns the number of characters in 
the string. If the argument is an array name, returns the number 
of elements in the array.  If the argument is a record, returns
the number of members in the record.
:LOADED ( )
bval = LOADED( program-name )

Returns a boolean value to say if a given program is loaded in memory
or not.  The program is identified by a string expression that must
match the PROGRAM name.
:LOCATE ( )
idx = LOCATE( value, array )
idx = LOCATE( key-string, search-string )

The first example returns the location of a given value in an array.  If 
the first parameter is an array or the second parameter is not an array, 
then the index value returned is -1 to indicate a parameter error.  

If the value cannot be found in the array, then a zero is returned to 
indicate "not found."  If the value is found in the array (by exact match
of both data type and value), then the index into the array is returned.

The second example searches the search string for an instance of the key-
string (an exact match is required).  If it is found, then the function
returns the 1-based offset into the string where the substring was found.
If it is not found, then zero is returned.
:LOCKS ( )
aval = LOCKS()

Returns an array containing information on all available LOCK objects.  
This includes the name, owner, wait state, hold count, etc.  See the
help information on the LOCK statement for more information. 
:LOWERCASE ( )
sval = LOWERCASE( string )

Returns a string with the alphabetic characters in the string 
converted to lower case if they are upper-case.
:MATCHES ( )
bval = MATCHES( pattern-string, test-string )

Uses standard Regular Expression syntax to define a pattern string
which is then used to search the test string.  If the test string
contains the pattern, the result is TRUE, otherwise it is FALSE.
The function will generate an error if the pattern string is not
correctly formed.

:MAX ( )
val = MAX( arg [, arg...] )

Returns the numerically largest value in the argument list, which
must contain at least one item.
:MEMBER ( )
item = MEMBER( record, "key" )

Returns the member of the record identified by the string expression
"key".  This is used to do indirect access to record members.

    x = { name: "Sue", age: 3 }
    
    y = x.name
    z = member(x, "name")

This code sets y and z to the same value ("Sue").  However, the
difference is that the member() function call allows the key
to be specified by a dynamic expression rather than a fixed
identifier.  See the function MEMBERS() for how to get a list
of the valid keys for a record.

The same functionality can be accomplished using string array
index values.  For example, X["Y"] is the same as MEMBER(X, Y).
:MEMBERS ( )
array = MEMBERS( record )

Returns an array of strings, containing the names of the members of
the record passed as a parameter.  If the parameter is not a record,
then generates an error.

    x = { name:"Sue", age: 3 }
    
    y = members( x )
    
This results in the variable Y containing the array [ "AGE", "NAME" ].
    
:MEMORY ( )
size = MEMORY( [type-string] )

Returns size of memory.  The parameter is a string that contains the
type of memory value to return.  If none is specified, then "USED" is
assumed.  If an invalid type string value is given, the function 
returns a value of -1.

The valid types are

     "FREE"       The amount of free memory in the process
     "USED"       The amount of memory used by the process
     "TOTAL"      The total amount of memory consumed
     "MAX"        The max memory available to the process
     "GC"         The free memory after garbage collection.
     

:METHODS ( )
aval = METHODS( objval )

Given a Java object value, return an array of strings describing the
available methods that can be called on that object.  The strings are
formatted using standard Java notation.

:MESSAGE ( )
str = MESSAGE( string [, argument ])
str = MESSAGE( status-record )

Given a message code like "SYNTAX" as the first argument, returns 
the formatted message text.  If the message has an argument, then
this should be supplied as the second optional parameter.

The second form assumes a record containing a status value, such
as the SYS$STATUS global variable or a value returned from a
SYSTEM statement. The elements of the status object are used to
form a formatted string which is returned as the function result.
:MIN ( )
val = MIN( arg [, arg...] )

Returns the numerically smallest value in the argument list, which
must contain at least one item.
:MKDIR ( )
bval = MKDIR(path [, flag])

Given a path, create the directory.  Returns true if the directory
was created.  Returns false if the directory already exists.  The
optional flag indicates if intermediate directories are created in
the path (default is true).  For example, "/tmp/a/b/c" will create
"/tmp/a" and "/tmp/a/b" as well as "/tmp/a/b/c" if this flag is set.
:MOD ( )
ival = MOD( m, n )

Returns the value of m modulo n.  That is, m is divided by n and the
integer remainder returned.  This can also be done using the modulo
operator ("%").  For example, 5 % 2 is the same as MOD(5,2).
:NAN ( )
bval = NAN( double )

Return TRUE if the argument is a not-a-number value (NaN), such as
what is returned when trying to input an incorrectly formatted 
double value, or the result of a division-by-zero operation.  If 
the value is not a NaN, then the function returns FALSE.
:NEW ( )
objval = NEW( class )

Returns a new object of the given class.  If the class is a string,
then it is a Java class name and the resulting object is a Java 
object.  If the class is the object named in a CLASS statement then
the result is a JBasic object.
:NUMBER ( )
val = NUMBER( string )

Returns a numeric value which is the contents of the string expression
parsed as a number.  For example, NUMBER("33") returns the numeric 
value 33.  If the string value cannot be represented as a number, the
result is a NaN (not-a-number) value.
:OBJECT ( )
rval = OBJECT( object )
val  = OBJECT( object, "field" )

Returns information about an object.  If the parameter is not an object
then an error is signaled.  If no second parameter is given, a record 
describing everything about the object is returned.  If the second 
parameter is given, it must describe an object attribute:

   CLASS    The class of the object
   ID       The unique ID number of the object
   ISCLASS  A boolean indicating if this is a CLASS object
   PARENT   The container parent of this object, if any.
:OCTAL ( )
ival = OCTAL( string-expression )
sval = OCTAL( integer-expression)

In the first example, the function converts a string containing
a octal value such as "157" into an integer containing the
decimal value of 111.  

In the second example, the integer decimal value is converted
to a string containing the hex representation, so a parameter
of 1234 becomes the string "2322".
:OPENFILES ( )
rval = OPENFILES()

This returns a record describing each currently-open file in the
current JBasic session, including the console input and output as
well as any user-opened files.  Each member of the record has the
file handle (the AS FILE clause of the OPEN statement) as its
name and a record describing the file as the value. 

For example, if you issue

    OPEN FILE "X.DAT" FOR OUTPUT AS FILE BOB

The the OPENFILES() function will return a record that will include
a member named BOB with a record as its value that describes the
file.  

    FLIST = OPENFILES()
    PRINT FLIST.BOB.FILENAME
    PRINT FLIST.BOB.SYSTEM

This prints the file name from the open file BOB, and then prints
a boolean value indicating if the file was opened by the system or
the user.  Note that the record FLIST in the example above only
tells the state of the file(s) at the time that OPENFILES() was
called; subsequently closing FILE BOB won't change the values 
in the FLIST variable - you should call OPENFILES() each time you
need up-to-date information about the open files.

Note that files opened with a numeric handle rather than a named
handle are not reported via OPENFILES().

:PAD ( )
sval = PAD( string, count )

Returns a string of the argument, padded with blanks to ensure that it
is 'count' bytes long.  If 'count' is a negative number, padding is
done the left; if 'count' is a positive number, then padding is done
to the right.
:PARSE ( )
sval = PARSE( string-buffer, n )

The PARSE() function performs a simplistic parsing operation on the
string in the first argument, and returns the nth token in the list.
For example, 

    NAME = PARSE("I SAW FRED IN HIS CAR", 3)
    
The result value in NAME is "FRED" because it's the third token in
the buffer.  The rules for defining tokens are the same as the 
JBasic language, so most punctuation, strings, numbers, and identifer
values are treated as separate tokens.

If you plan on doing a lot of parsing of a string, you should use
the TOKENIZE() function instead which describes each token and what
kind it was, so that "BOB" and BOB are identified as different types
of tokens (a string versus an identifier), etc.
:PASSWORD ( )
sval = PASSWORD( string-expression )

This function creates a one-way string encryption of another string.
It is similar to the CIPHER() function except that the encryption
string is not known.  This is used to process passwords which are 
never decrypted but must be compared.

     LINE INPUT "Password:", PW
     CODED_PW = PASSWORD(PW)
     IF CODED_PW <> USER.PW THEN SIGNAL FAULT

This example inputs a password value from the user, and then determines
the encoded password value.  This is compared with a previously stored
password value to see if an error occurs.  The general idea is that the
program should encode passwords as soon as the user enters them so they
are not maintained in plain-text form.  Any subsequent storage or test
of the password should use the encoded password.
:PATHNAME ( )
sval = PATHNAME( file-name-expression )

This parses the file name in the string expression and returns
the path; that is, the part of the file name containing the
directory containing the file.  For example, the expression
PATHNAME("/users/tom/bob.txt") would return the string "/users/tom/".
No attempt is made to determine if the file actually exists or is
a valid name.
:PERMISSION ( )
bval = PERMISSION( permission-name-string )

This tests to determine if the current user has the given permission,
expressed as a string.  If the user is running a standalone JBasic
session, then the user always has all permissions. 

If the user is running as an embedded task and sandbox mode is enabled,
or running in multiuser mode, then specific permissions may be enabled
or disabled by the calling program or administrator.  In this case, the
PERMISSION() function can be used by a program to determine if it is
about to perform an operation that might result in an error.  For 
example, the HELP command requires the FILE_IO permission to be able
to read the online help data.  It tests the PERMISSION("FILE_IO") value
to determine if it can offer help or not.

See the user's guide for more information about permission names and
how they are used in JBasic.
:PROGRAM ( )
rval = PROGRAM( "name" )

Returns a record describing what the named program.  The record contains
fields describing the current run state of the program.  The record also
contains an array called LINES that has a string element for each line of
text of the program, so a program can algorithmically examine the source
of other programs.
:PROPERTIES ( )
aval = PROPERTIES()

This returns an array with the names of all the currently known Java
properties for the current session.  These are named string values
set up by the Java environment itself or during the invocation of
Java that started the current JBasic session.  The result is an array
of string names that can be used with the PROPERTY() function to get
individual values.
:PROPERTY ( )
sval = PROPERTY( property-name-string )

Return a single Java property as a string.  The name must be a string
expression that defines an existing Java property.  These may have been
created by the Java environment itself or by the invocation of Java
that started the current JBasic session.

For example, PROPERTY("user.language") returns the two-character string
defining the current language of the user, and PROPERTY("file.separator")
returns the character used in creating path names with more than one 
part ("\" on Windows or "/" on Unix, for example).
:QUOTE ( )
sval = QUOTE( string )

Returns the argument enclosed in quotation marks.  This can also be
done using string concatenation; QUOTE( NAME ) is the same as the string
expression "\"" + NAME + "\"".

:RADIX ( )
sval = RADIX( integer-value, radix )

This converts a decimal integer to a string containing a representation
of a number in an arbitrary radix.  For example, RADIX(21, 2) will
convert the decimal number 21 to the base-2 (binary) number "10101"
and return the result as a string value. Any base between 2 and 36 
may be used for this conversion.  Also see the DECIMAL() function which
performs the reverse operation of converting numbers in arbitrary 
radixes to decimal.
:RANDOM ( )
dval = RANDOM( )
dval = RANDOM( maxval )
dval = RANDOM( minval, maxval )

Generates a floating point random number.  If no arguments are given,
then a number x, such that 0.0 <= x < 1.0 is generated.  If one argument
is given, then x is between 0.0 and that given value.  If two arguments
are given, they are the minimum and maximum values returned by the 
function.
:RANDOMLIST ( )
array = RANDOMLIST( max )
array = RANDOMLIST( min, max )

Generate an array of integers sorted in a random order.  If one argument
is given, then the list contains integers between 1 and that maximum
value.  If two arguments are given, the array contains integers between
the minimum and maximum values.  In a RANDOMLIST() array, no integer
appears more than once and all possible integers in the range are
represented.

For example,

    cards = RANDOMLIST(52)
    
This will generate an array named cards[] that has 52 elements numbered
from 1 to 52, in random order.  This can be used to create a shuffled
deck of cards for a game, for example.
:RECORD ( )
rval = RECORD( key-string, value [, key-string, value ...])

This function takes an even number of arguments and treats each 
successive pair of arguments as a member name and a value.  The
resulting pairs are encoded as a record and returned as the 
result.  For example,

    ID = 1001
    MYNAME = "Tom"
    X = RECORD( "ID", ID, "NAME", MYNAME )

Creates a record value of { ID:1001, NAME:"Tom"} as the result.  This
can be done as easly by creating a record constant if desired.

:REPEAT ( )
sval = REPEAT( string, count )

Returns a string containing the first argument repeated as many times
as specified by the second numeric argument.  The string can be a single
character or a longer string.  If the string is empty or count is less
than one, then an empty string is returned.

This same effect can be achieved by multiplying a string by an integer
value, which replicates the string value the given number of times.
:REPLACE ( )
sval = REPLACE( edit-string, find-string, replace-string )

The edit-string is searched for an instance of find-string.  If it is
found (by exact, case-sensitive match) then the find-string is replaced
with the replace-string and the resulting string is returned.  If the
find-string is not found anywhere in the edit-string, then the edit-string
is returned unmodified.
:REPLACE ( )
sval = REPLACE( source-string, search-string, replace-string )
sval = REPLACE( source-string, search-string, replace-string, count )

This searches the source-string value for the first instance of the
search-string value, and replaces it with the replace-string value.
The search and replace strings can be of different lengths.  For 
example,

REPLACE( "HERE IS A TEST", "IS", "WAS") results in "HERE WAS A TEST"
REPLACE( "THIS IS A TEST", "IS", "WAS") results in "THWAS IS A TEST"

In the first example, the replace is done only once, even if the 
search-string occurs more than one time in the source-string.  By
specifying an optional count, it indicates the number of successive
occurances in the search string that are replaced.  The count must
not be less than 1, but can be greater than the actual number of
occurrances in the search string.
 
:RIGHT ( )
sval = RIGHT( string, count )
aval = RIGTH( array, count )

Returns a string containing the 'count' right-most characters from the
string argument.  If count is less than one, then an empty string is
returned.

In the second example, the parameter is an array, and the function
returns the last 'count' elements of the array.  For example, the
expression RIGHT([ "T", 3, -5.8], 2 ) returns the result [3, -5.8]
:ROUND ( )
dval = ROUND( double, n )

The double value is rounded to the nth decimal place.  For example,
the value of ROUND(3.141529, 5) is 3.14153.
:SECONDS ( )
dval = SECONDS()

Returns a floating point value that is the number of seconds since
JBasic was started, accurate to about a millisecond.  This can be used
to time events, etc.
:SETBITS ( )
sval = SETBITS( sval, value, start, len )

Given a buffer stored in a string, insert an integer value into the
buffer given a starting bit position and length.  The position maps
the entire buffer into a single long string of bits.  So bit position
zero is the first available position, and is stored in the highest-
bit position of the first byte.  The length can be any value between
1 and 32 and the value must be a positive number that can be expressed
as an integer.  The function result is the buffer, but with the bit
field value inserted at the specified position.

:SIZEOF ( )
ival = SIZEOF( expression )

Calculates the size of an expression in bytes.  The expression can be
a complex array or record, in which case the size is the cumulative
size of the values given. This indicates how much memory the object
consumes.
:SORT ( )
array = SORT( array-value )
array = SORT( v1, v2 [, v3...] )

The array parameter is sorted by the values in the array, and a new
copy of the array is returned as the result.  The array must be a 
one-dimensional array.

In the second form, all the arguments passed to the function are
converted to a single array and that array is then sorted and is
the function result.  So  SORT( 15, 3, 33, 4) returns the array
[ 3, 4, 15, 33 ] as its result.
:SPELL ( )
sval = SPELL( integer-value )

This function converts the number to a text representation based
on the current language setting.  As of JBasic 2.7, only English(EN)
and French(FR) are supported.  For example,

   SPELL( 351 ) returns "three hundred fifty one" in English, and
   SPELL( 28 )  returns "vingt-huit" in French.
:SQRT ( )
dval = SQRT( numeric-value )

Returns the square root of the argument as a double precision value.
:STRING ( )
sval = STRING( any-value )

Returns the argument formatted as a string value, formatted the same
way that the PRINT statement formats a value. 
:SUBSTRING ( )
sval = SUBSTRING( string, start, end )
aval = SUBSTRING( array, start, end )

Returns a string value that is a substring of the first argument, 
starting with the 'start' character and ending with the 'end'
character positions.  If end-start is less than one, an empty
string is returned.  If start is less than one or end is greater
than the length of the string, then one and string length are assumed.

In the second example, the parameter is an array, and the function
returns the elements 'start' through 'end' of the array.  For example, 
the expression SUBSTR([ "T", 3, -5.8], 2, 3) returns the array
result ["T", 3]
:SUM ( )
val = SUM( arg [, arg...] )

Returns the numeric sum of the arguments.  Differs from TOTAL() in that
it cannot handle string arguments.
:SYMBOL ( )
rval = SYMBOL( symbol-name-string )

Returns a record describing the symbol identified by the string parameter.
The record contains fields describing what's know about the symbol:

 +--------------+-----------------------------------------+
 | Field        | Description                             |
 +--------------+-----------------------------------------+
 | NAME         | Name of the symbol                      |
 +--------------+-----------------------------------------+
 | READONLY     | Boolean indicating a read-only symbol   |
 +--------------+-----------------------------------------+
 | TABLE        | Name of table containing the symbol     |
 +--------------+-----------------------------------------+
 | TYPE         | Numeric type code of value              |
 +--------------+-----------------------------------------+
 | TYPENAME     | String type code of value               |
 +--------------+-----------------------------------------+
 | VALUE        | XML string showing current value        |
 +--------------+-----------------------------------------+
:SYMBOLS ( )
aval = SYMBOLS( [ table-name-string] )

Returns an array containing the names of all the symbols in the given
symbol table.  If no argument is given, then the most-local symbol
table is used.  The resulting array elements can be used as input to
the SYMBOL() function to learn more about each individual symbol.
:TABLES ( )
aval = TABLES()

Returns an array containing the names of all the symbol tables that are
currently active.  The most-local symbol table is listed first, and
the global tables of "Global", "Constants", and "Root" are always listed
last in the array.  These elements can be used as arguments to the 
SYMBOLS() function to get a list of symbols in each table.
:TAN ( )
dval = TAN( numeric )

Calculates the trignometric tangent of the numeric argument and returns
it as a double.
:THREAD ( )
rval = THREAD( thread-name-string )

Returns a record describing the characteristics of an execution thread
by name. Use the THREADS() function to get a list of the thread names, 
or use the AS(name-variable) clause on CALL or EXECUTE statements that
start threads to capture the name of a given thread.

The record contains fields describing what's know about the symbol:

 +--------------+-----------------------------------------+
 | Field        | Description                             |
 +--------------+-----------------------------------------+
 | CMD          | Command executed on the thread          |
 +--------------+-----------------------------------------+
 | CODE         | Completion code of the thread           |
 +--------------+-----------------------------------------+
 | MESSAGE      | Text version of the completion code     |
 +--------------+-----------------------------------------+
 | NAME         | The thread name                         |
 +--------------+-----------------------------------------+
 | RUNNING      | Boolean, true if thread still running   |
 +--------------+-----------------------------------------+
 | START_TIME   | DATE() value of thread start time       |
 +--------------+-----------------------------------------+

:THREADS ( )
aval = THREADS()

Returns an array of strings containing the names of all threads that
are known to the current session (i.e. started by the current session).
If no threads have been run then an empty array is returned.
:TIMECODE ( )
ival = TIMECODE()

This extracts the millisecond component of the current timestamp and
returns it as an integer.  This can be used to create largely random
seeds for random number generators, etc.  Two subsequent calls to
TIMECODE() are not guaranteed to return different numbers.
:TOKENIZE ( )
array = TOKENIZE( string )

Returns an array of records, describing all the tokens in the string.
Comments (in the JBasic style) are not included.  Each array element
is a record that describes the next token.  The records contain the
following members:

     KIND         A string describing the token.  The possible values
                  are STRING, IDENTIFIER, INTEGER, DOUBLE, and SPECIAL.
                  There is no special type for constant identifiers
                  such as "TRUE" or "INFINITY"; these are returned as
                  standard identifiers.
                  
     SPELLING     The text of the token.  Identifiers will have been
                  normalized to uppercase.
                  
:TOTAL ( )
sum = TOTAL( arg [, arg...] )

Returns the numerical sum of it's arguments if they are numeric, or
a concatenation of the arguments if they are strings.
:TRIM ( )
sval = TRIM( string )

The string argument has all leading and trailing whitespace (blanks,
tabs, line endings, etc.) removed.  For example, TRIM("   \tBob  ")
will return the string "Bob".
:TYPE ( )
ival = TYPE( expression )

Returns an integer value that is the data type of the expression.  If
the expression is a single variable, returns the type of that variable.
Types match the predefined system variables like SYS$TYPE_INTEGER or
SYS$TYPE_STRING.
:TYPECHK ( )
bval = TYPECHK( expression, "descriptor")

Tests a value against a description of a data type to see if it matches.
Unlike the TYPE() function which simply returns the type of the expression,
this function matches every item even in complex data types.

The expression can be any constant, variable, or expression value.  The
descriptor must be a string value or constant that describes the types. 
The function returns true if every item in the expression value matches
the corresponding type in the descriptor.

PRINT TYPECHK( D, "integer")

This simple example returns true if the variable D is of type INTEGER.
The type descriptor can contain the type names INTEGER, DOUBLE, STRING,
or BOOLEAN. In addition, the type NUMBER will match either an integer
or double value.  Finally, the value ANY may be used to match any type.

This becomes more interesting when comparing complex types (arrays
and records). In the case of arrays, the number of elements must match
and each element in the array must match.  In the case of records, the
number and name of the key values must match as well as the data values.

PRINT TYPECHK( PERSON, "{NAME:STRING,AGE:INTEGER,SALARY:[NUMBER,NUMBER]}")

In this case, the item PERSON must be a record with key values NAME, AGE
and SALARY. The value for NAME must be a string, and the value for AGE
must be an integer.  The value for SALARY must be a two-element array
where each member must be either an INTEGER or DOUBLE.

An additional use for this feature is in user-written functions, which
can test the argument list for type correctness.  In a user-written
function, the arguments are always available in an array $ARGS which
contains one item for each argument value.  

IF NOT TYPECHK($ARGS, "[NUMBER, STRING]") THEN SIGNAL ARGERR

This statement requires that the first argument be an INTEGER or DOUBLE
and the second argument be a string, by testing the $ARGS array for
conformance with the type descriptor.  If it does not match, then an
argument error is signalled from the function.

:UNIQUIENAME ( )
sval = UNIQUENAME()

Returns a string name that is guaranteed to be unique for the life of
the JBasic session, and is also unique among all threads and sessions
created by that JBasic session.
:UNIQUIENUMBER ( )
ival = UNIQUENUMBER()

Returns an integer value that is guaranteed to be unique for the life of
the JBasic session, and is also unique among all threads and sessions
created by that JBasic session.
:UPPERCASE ( )
sval = UPPERCASE( string )

Returns a string with each alphabetic character in the string converted
to uppercase.

:URL ( )
sval = URL( url-string )

Parse the URL in the string argument, and return a record that describes
the elements of the URL.  The record contains the following fields:

Field         Description
----------    ------------------------------------
HOST          The host name; i.e. apple.com
PATH          The path name; i.e. index.html
PROTOCOL      The protocol name; i.e. HTTP or FTP
QUERY         A record describing the query fields
QUERYSTRING   The unprocessed query string
USERINFO      Any user info before the host name

The QUERY result is also a record, with a member for each key in the
query string.  The value of the member is an array that contains all
values found with that key.  For example,
   
 X = "http://abc.org/thread?index=5&format=Y&key=HELLO&key=BYE&quote=%22"
 Y = URL(X)

Would result in the following record values

    X.HOST         "abc.org"
    X.PATH         "thread"
    X.PROTCOL      "http"
    X.QUERYSTRING  "index=5&format=Y&key=HELLO&key=BYE&quote=%22"
    X.QUERY        { FORMAT: [ "Y" ], KEY: [ "HELLO", "BYE" ], QUOTE: "\"" }
    X.USERINFO     ""
    
Note that for the parsed query, even if there is only a single value it 
is represented as an array for uniformity. Also note that the QUOTE item 
was expressed using a hexadecimal value (22) which is converted to a 
character (in this case, a double-quote character).

:XML ( )
sval = XML( [ value[, formatted [, root-tag ]]] )

Produce valid XML strings, suitable for creating strings or files
containing standards-compliant XML data that can be exchanged with 
other XML-aware programs, or used to store data in a platform-neutral
fashion. The resulting string can be re-read using the XMLPARSE()
function.

If no parameter is given, then the result is the generic XML header
normally put at the start of an XML file.  

The first parameter is any JBasic value converted to a formatted XML 
string.  The root node is a <JBasicValue> in this case, and will
contain any arbitrarily complex value (scalar, array, record, etc.).

If the optional second parameter is present, it is a Boolean value that
indicates if the XML string is formatted with line breaks and indented
for readability.  The default is "true", resulting in formatted XML.

The third optional parameter includes a root tag name for the resulting
XML. If omitted, the default is a <JBasicValue> root tag.  This is the
correct tag type for the XMLPARSE() function.

:XMLCOMMENT ( )
sval = XMLCOMMENT( [comment] )

Generate a valid XML comment string.  If no argument is given, the
result is the standard XML header string.  If a comment is given,
it is returned as a properly formatted comment string. The user
can combine XMLCOMMENT() and XML() functions to produce arbitrary
XML definitions.
:XMLPARSE ( )
val = XMLPARSE( xml-string [, root-tag] )

Parse a string containing properly formatted XML definitions of a Value,
and return the represented value as the function result.  If the XML is
not properly formatted then an error occurs.  You can generate an XML
string using the XML() function.

Any comments in the XML string are ignored.  If more than one Value is
found in the string, then the result is an array of those values.

If the optional second argument is given, it represents the root tag
that is searched for to locate JBasic values.  The default tag is
<JBasicValue> if this parameter is not given. This value must match
the root tag given in the XML() function call that creates XML values
if explicitly specified.
...
Need the triple-dot to break function key parsing.
...
.CHANGES

You can get release notes for each release by using the command

    HELP CHANGES <version>
    
Where version is the specific version, such as 2.2 or 2.2-3. 

Note that all changes prior to 2.0 are now documented in the file named
CHANGE-ARCHIVE.TXT in the Eclipse project directory.  Consult that file
for information about what was changed in releases prior to 2.0.
..

]CHANGES 2.0

The introduction of multiuser mode calls for a major release change.
The work to fully support multiuser mode will dominate the next several
release cycles.

    October 10, 2007
    ----------------
    1. Added multiuser mode.  This lets an instance of JBasic act as a 
       multiuser server.  Users connect via a telnet client (port 6100, 
       by default) and each connected user has their own shell.  The 
       global variables of each shell are configured for the remote users 
       rather than based on  the user running the JBasic server.  The 
       users run in "sandbox" mode to prevent damage to the local file 
       system.
       
    2. SET MULTIUSER enables the multiuser mode. At the time of this 
       command, the array SYS$USERLIST is read to describe the user 
       id's allowed to connect this mode.  Note - this is pretty clunky 
       now and should be modified to support a control file, etc.
    
    3. This is implemented by an adaptation of the wimpi.net TelnetD open
       source product, used under the terms of the GPL license.  This
       portion of JBasic is Copyright (c) 2000-2005 Dieter Wimberger.
       
    4. Fix security hole where ASM statement could be used to generate 
       code to get the user out of sandbox mode.
       
    5. The USERS() function returns an array with the names of all 
       currently defined users.
       
    6. The PERMISSION("name") function returns true or false if the 
       current user has the given permission. This is always true for 
       sessions that are not in sandbox mode.

 
    October 16, 2007
    ----------------
    1. Passwords in the user data passed to the UserManager are now 
       encoded using the new encryptedString() method of SimpleCipher.
       This is a one-way encryption.  The same method is used by the 
       UserManager to compare the string. The load() method of the 
       UserManager assumes that the password is already encoded when 
       it get the data via the value array.
       
    2. User profile information is loaded from the file "JBasic-users.txt"
       by default when multi user mode is enabled.  This file contains a
       record for each user, including a hashed password.
       
    3. The user can use the SET PASSWORD="string" command to change their
       own password.
 
    October 20, 2007
    ----------------
    1. Add permissions.  The UserManager can add a permission (really 
       just a case-normalized string) to a user, and code can check 
       for the permission.  If you are not in the sandbox you have 
       no permission requirements.  A permission of "ALL" grants all 
       privileges even if you are in the sandbox.  The _SBOX opcode 
       now can check for a specific privilege.  For example the ASM 
       statement requires the "ASM" privilege to run in a sandbox.
       
    2. When in sandbox mode, file access paths cannot contain relative
       path syntax (like ".." to go up a directory) and are prefixed 
       with the user's SYS$HOME directory location.
       
    3. UserManager requires ADMIN_USER, ADMIN_SERVER, or both to 
       change the state of a user or the server.
       
    4. Fixed trivial but annoying bug in handling of backspace from 
       terminal sessions.
    
    October 27, 2007
    ----------------
    1. Implement SET SERVER and SHOW SERVER commands to be more like 
       standard syntax and existing reserved verb names.
       
    2. Added additional permissions granularity so KILL requires 
       FILE_IO if closing a file, else DIR_IO if killing a file by 
       name, etc.
       
    3. Added path management functions to UserManager so that path 
       names could be converted between user-sandboxed and file-system 
       path names.  A privilege of FSNAMES means this conversion is 
       not done and the user has access to the full file system.
       
    4. Home directory path names given in the UserManager database 
       are now converted to a system-specific canonical name.  This 
       is required for the user manager to work right.  This also 
       means that a SAVE of the UserManager database makes the file 
       platform-specific.
       
    5. Changed format of SHOW SERVER [STATUS] and SHOW SERVER USERS 
       to convey more information in a somewhat more readable format.
       
    6. SET SERVER MODIFY USER "name" ... takes the same parameters 
       as ADD USER but modifies an existing user record.  This lets 
       the administrator change any arbitrary field for an existing 
       user.
       
    7. Users require the PASSWORD or ADMIN_USER privilege to change 
       their own password. 
       
    8. Fixed numerous bugs with password handling.  Also bind a 
       specific User object instance to each session to make acquiring 
       user database info much quicker.
    
    October 31, 2007
    ----------------
    1. Detect when a user's home directory is not valid and report 
       this error to the user and to the controlling session console.
    
    2. Add new SET NEEDPROMPT to generate the _NEEDP code in user-
       written programs. This eliminates the need to give the "ASM" 
       privilege to  users (the HELP verb for instance used ASM to 
       generate the _NEEDP code) and still get the proper prompt 
       handling when in NOPROMPTMODE.
       
]CHANGES 2.0 - 1

Changed version number to 2.0-1 to signify next round of modifications 
to the 2.0 release.  These are expected to largely be "fit and finish" 
changes.  

Also, starting with this release, items in the CHANGES that have been 
put in the code but not yet in the user manual are marked with [DOC].
This includes items from previous releases.  When the feature is 
documented, the [DOC] tag will be removed from the item.  

    November 2, 2007
    ----------------
    1. Change the prompt when in server mode to "SERVER> " so the 
       session is easily identified as a server session.
    
    2. Allow an optional expression after SET SERVER START that is 
       the listening port number to use.  If not give, SYS$PORT is 
       used.  If that is not set, then 6100 is assumed.  Once a port 
       number is given, SYS$PORT is set to that value, so subsequent 
       SET SERVER START commands in the same session will use the 
       same port.
       
    
    November 6, 2007
    ----------------
    1. More than one instance of a user can log in.  Each gets a copy 
       of the User object associated with the session.  All active 
       sessions are tracked in the TreeMap called activeSessions 
       that is static on the JBasic root class.
       
    2. SET SERVER QUIT now requires an instance ID number rather than 
       a user name.
       
    3. SHOW SERVER SESSIONS lists active sessions.  SHOW SERVER USERS 
       will now just show user data.
       
    November 28, 2007
    -----------------
    1. Added basic support for logical names in file names. There is 
       one process-wide logical name table.
       
    2. Logical names are loaded and saved in the user account database 
       file.
    
    3. Fixed bugs in handling of home directories for LOAD operations.

    December 6, 2007
    ----------------
    1. Fix bugs in comparison of RECORD types, equality and inequality 
       tests should be permitted if all key's values match.
    
    2. Fix bugs in handling of KILL #f syntax.
    
    3. Clean up Value object definition; remove unneeded fields and 
       public attributes.
    
    4. Radix functions (RADIX, BINARY, OCTAL, HEXADECIMAL) will convert 
       a value in the given base back to decimal if it is passed as a 
       string. So BINARY(5) returns "101", and BINARY("101") returns 5.
       This means each function acts like the DECIMAL() function when 
       the value passed is a string, and with an assumed radix.
       
    5. General housekeeping in the Value class, to overload method 
       names so that array and record are treated the same except
       for the key type (integer versus string).
    
    6. Some general branch optimizations added, especially for cases 
       of tests for zero or non-zero, and branches around GOTO statements.
    
    December 15, 2007
    -----------------
    1. Add support for exponential notation in tokenizer.  Can't believe
       I hadn't noticed that one before...
    
    January 1, 2008
    ---------------
    1. Added type declarations in FUNCTION and PROGRAM statements, so you
       can specify the type to coerce the value to.  Only scalar values
       or ARRAY are permitted; you cannot coerce something to a RECORD.
    
    2. Added ARGC instruction to test to see if all required arguments 
       are given in a function or program call.  If arguments have default
       values, the default values are moved into the $ARGS array available
       at runtime. If the argument list ends in the ellipsis ("...") then 
       no argument length checking is done.
    
    3. Allow SUBSTR, LEFT, and RIGHT to operate on arrays as well as 
       strings.  So RIGHT([22, "T", 3.5], 2) is [ "T", 3.5 ], for example.
       
    January 7, 2008
    ---------------
    1. Added optimizations for cases when constants where followed by 
       type conversions.  This most often happens in assignment statements 
       with an explicit type (DOUBLE X = 3) or a cast (Y = STRING(33.0) 
       operation.
    
    2. Allow explicit types in RECORD value expressions. For example,
          LET X = { DOUBLE Y: 55, BOOLEAN Z: 3.0 }
       
       The resulting record has a field Y that is a double (as opposed 
       to an integer) and a field Z that is a boolean that is true, as 
       opposed to a double of a non-zero value.  The same effect can 
       be generated with casts,
       
          LET X = { Y: DOUBLE(55), Z: BOOLEAN(3.0)}
          
    3. Fix bug in value conversion between strings and boolean values.
    
    4. Allow DO..LOOP UNTIL and DO..LOOP WHILE forms, as well as the 
       form DO..UNTIL and DO..WHILE.  Essentially add a vestigial 
       LOOP keyword.
      
    5. The destination of a GOTO or GOSUB can be a comment line, which 
       transfers control to the next available statement after the 
       comment.
]CHANGES 2.2
Changed incremental release number to 2.2

These will be additional fit-and-finish changes to the 2.0 family of 
releases. A numbering error caused 2.0-1 to be unintentionally numbered 
2.1 in the release kits, so let's just continue down that path for now.

    March 4, 2008
    -------------
    1.  Misc cleanup of code.  Removing long-commented-out vestigial code,
        adding comments to code that was badly documented, some refactoring
        particularly in expression compiling to reduce the size/complexity
        of the compile3() method.

    April 22, 2008
    --------------
    1.  Major internal redesign of error handling. Previously, status was
        reported by "percolating" a Status object.  This meant that most
        callers had to explicitly check the error, and either return it or
        print it out.  The new design uses Status for return values for
        compilation but uses the JBasicException object to encapsulate the
        status for throw operations and matching try/catch blocks. This 
        means that at runtime, most error conditions aren't checked for
        explicitly but assume a throw will be done as needed.  This also
        cleans up routines that needed to also return a Value.
        
    2.  Fix bugs introduced that broke the debugger's ability to STEP, which
        really involved how status substitution parameters are stored as
        integers or strings.
    
    3.  Clean up lots of error handling, mostly in functions.
    
    4.  Fix bugs in JBTest test suite, and in handling of embedded mode.
        Mostly this involves dealing with newly thrown exceptions that
        previously resulted in null return values.
        
    5.  Rewrite TIME to be compiled code, remove XTEST
    
    6.  Change error messages to include program name and line number when
        it is known.  SYS$STATUS now contains PROGRAM and LINE fields to
        match. This information is not printed for PROTECTED programs, and
        the fields in SYS$STATUS do not exist when they are not available.
    
    May 5, 2008
    -----------
    1.  Add _DEBUG 3 opcode operation to print the stack, to be used in
        debugging generated code streams.
    
    2.  Modified _STMT so it detects data left on the stack by the previous
        statement, which typically indicates a code generation error.
    
    3.  Overdue spelling cleanup of the help file.
    
    4.  Replaced underlying sort used by SORT statement, SORT() function
        with a quicksort implementation that is zillions of times faster
        than the previous dumb bubble sort for interesting array sizes.
    
    5.  Add array range notation. For an array X, the expression X[I..J]
        means the array comprised of members of X from index I through
        index J, inclusive.  So if X is ["A", 55, "C", true], then the
        range expression X[2..4] is the array [55, "C", true].  This can
        also be used with a string, so if X is "This is a test", then
        the expression X[1..4] is the string "This".  The range operator
        is really just a shorthand for the substr() operation, and will
        produce identical results.
        
        Updated the help for ARRAYS to match, and added TEST$ARRAY4 as a
        unit test of the range function.
    
    6.  Released 2.2 to SourceForge.  Then, discovered dumb bug in the
        tokenizer that would crash JBasic when a trailing period was in
        a floating point constant... a side effect of adding the range
        token.  Had to release 2.2-1 a day later to clean up the mess.

]CHANGES 2.3
Version 2.3 is a bug-fix release, with primary focus areas including
making multi-user mode more robust and adding XML support to JBasic.

    May 13, 2008
    ------------
    1.  Added toXML() method to the Value class so they can be converted 
        to XML for data interchange, etc.  Added a new JBasic function 
        XML(v) that generates this XML string in JBasic programs as needed.
        This accepts an optional second parameter that indicates if the
        output is formated with line breaks and indentation.
        
    2.  Added XMLParse class to parse Values from XML data.  Instantiate
        an XMLParse object when you need to parse such data, and the 
        parseXML() method returns a Value containing the represented data.  
        Added JBasic function XMLPARSE() which turns a string into a 
        Value.
    
    3.  Added a unit test TEST$XML to validate encode and decode of Value 
        types.
    
    4.  Added ability to create a program from a Value.  If you use the
        PROGRAM() function to define a record describing the program, 
        you can use this via the NEW USING(v) statement to recreate the
        program.  This would allow you to transmit the contents of a
        program as XML and reconstruct it elsewhere.  The NEW USING(v)
        takes a record value that must have at a minimum the NAMES
        field with the program name and the LINES array containing the
        text of each statement.  Note that this would also allow a
        program to algorithmically write a new program in memory by
        adding elements to a value and then later creating the program.
        You cannot create a program name that already exists.
     
     5. The LOAD command now detects when an input file contains an XML
        definition of a program, such as created via XML(PROGRAM("foo")).
        In this case, the XML is parsed and a new program is created
        using the XML definition in the file.  In this mode, the LOAD
        command can only load a single program object from the file;
        multiple <Value> root objects are not currently supported.
     
     6. Allow SAVE XML "file.xml" command to save the current program
        as an XML file.  This can only be run as an immediate command
        in the console; it cannot be put in a program since it only
        works on the current program (like LIST, etc.).  The resulting
        file can be loaded using the enhanced LOAD operation above.
     
    May 15, 2008
    ------------
    1.  Simplify storage of Program objects in XML by removing fields that
        are only relevant to runtime information (number of nested LOOPS
        currently running, for example).
    
    2.  Change XML definition so record key fields are XML tags rather
        than attributes of <KEY> tags.
        
    3.  You can subtract a string from a record, which uses the string as
        a field name to remove the member.  It is a runtime error if the
        field name does not exist.
    
    May 18, 2008
    ------------
    1.  Improved command line handling.  Adding "-help" to the command line
        displays the COMMAND LINE help module in this file.  Fixed long
        standing problem with command line command invocation; now the
        "-cmd" or "-exec" must be the last item on the command line because
        everything that follows it will be put in SYS$INITCMD and executed
        by JBasic's main shell.  This only applies to invoking JBasic from
        a command line shell; running as an embedded program does not
        execute a default command line of any kind.  Updated the user's
        guide accordingly.
    
    2.  Fixed a handful of bugs in reporting errors in functions; some errors
        not properly signaled or signaled the old way via null function
        return values.
    
    3.  Minor improvements in XML error handling, and allowing the XML stream
        to contain multiple values, in which case XMLPARSE() returns an array
        with each of the values represented.
        
    4.  Allow INPUT X AS XML which reads as much input as needed to build an
        XML string, which is then processed and stored in X.  This lets us
        read multi-line XML from a file as a single JBasic statement.
        
    5.  Allow INPUT X AS RAW XML which returns a string from the file with 
        the next XML specification in the file.  The first tag found must
        be matched with an ending tag, but the root tag can be of any type.
    
    May 21, 2008
    ------------
    1.  User data for multiuser mode is now stored as XML, with a default
        database file name of "JBasic-users.xml".

    2.  Expand the XML() function to support creating the XML header string
        and adding comments to the XML output. Added XMLCOMMENT() which just
        handles the XML header or comment syntax, without a value.  This
        lets the user combine XMLCOMMENT() and XML() to create arbitrary
        XML strings.
    
    3.  Restructured the users database file slightly, so it is correct XML.
        The entire dictionary is represented in a single JBasicValue that
        is a record with an array of logical names and an array of user
        names.
    
    4.  Added SET SERVER DEFINE to create logical name values, SHOW SERVER
        LOGICAL NAMES to display logical name definitions, and SET SERVER
        DELETE LOGICAL NAME to remove them from the active list. This 
        allows command-line editing of the active logical name list, which
        previously was done only by editing the user definition file. Now
        that this file is in XML, it's pretty cumbersome to add names via
        a text editor so new commands support it directly.
    	
    5.  Allow arbitrary root tags in XML.  The XML() and XMLPARSE() functions
        accept an optional final parameter that is the root tag name.  The
        default is <JBasicValue>.  The underlying XMLManager now supports
        arbitrary root tags.  The user database and XML program load/save
        operations now have descriptive root tag names.
 
    JUNE 1, 2008
    ------------
    1.  Fix permissions error handling in FILES verb for sandboxed users.
    
    2.  Fix bugs in file handling for remote users that caused errors to be
        thrown to server process on CLOSE or QUIT commands.
    
    3.  Bug fixes to handle logical name prefixes more correctly.  Workspaces
        can now be defined using logical names, and these can be outside of
        the normal user's defined space. The functions FILETYPES() and FILES()
        now return path names converted to logical names when possible. A
        logical name that starts with an underscore "_" character is not
        displayed in either function.  It is recommended that workspaces
        be stored in a "_WS::" or similar prefix so they are not visible
        to remote users.
    
    4.  Internal cleanup of multi-user mode relationship between sessions
        and users.  There was a lot of poorly-structured code left over from
        when only a single instance of each user was allowed to log in at a
        time.  Now each session has a user identity pointing to a (shared)
        record describing the user, so a many:one relationship exists between
        sessions and users.  Separately, the root JBasic object statically
        holds a list of active sessions regardless of users.
    
    5.  Created SESSIONS() function that lists active sessions, and fixed
        numerous bugs in how user and session data is displayed with SHOW
        SERVER USERS and related commands.
    
    June 10, 2008
    -------------
    1.  Clean up some internal Java by using parameterized classes for
        various lists, maps, etc. to make the code easier to read.  This
        lock us into Java 5.0 as a baseline for compilation.

    2.  REWIND is now supported for INPUT files as long as they are not
        the console/terminal.  This is a very expensive operation (requires
        closing and reopening the file) and should not be used carelessly.
        
    3.  Fix a bug in the xmlparse() routine that doesn't handle nested
        arrays correctly. 
    
    4.  Fix miscellaneous bugs in handling of file identifiers that are
        invalid or represent files that are not currently open. Fix 
        expression evaluator handling of exponentiation precedence.
    
]CHANGES 2.4
Started new development release cycle.

    July 1, 2008
    ------------
    1.  Added _LOCREF which "Loads or Creates" a reference on the stack
        to a named variable.  Used to create reference-based local variable
        or get copy of data from non-local storage.  Added _SET which uses
        TOS(0) as destination to copy contents of TOS(1).  So a sequence

             _INTEGER 1
             _LOCREF "X"
             _SET

        will store the value 1 in the variable X, creating it locally if
        needed.  This is in anticipation of expanding how LValues work to
        permit more complex addressing like multi-dimensional array refs.
    
    2.  Started changing LValue so that it uses reference notation. This is
        currently controlled by a constant USE_REFERENCE in the LValue class
        that enables the new mode of operation.  This is enabled by default.
        The new mode allows syntax like
        
        	A.B[1].C = 55
        
        Which sets the members/elements accordingly. When used in an LVALUE,
        members and array indexes that do not exist are created dynamically.
        This also enables reference expressions in LINE INPUT, INPUT, and
        READ statements, such as
        
            INPUT X[IDX+1].NAME
            
    3.  The LValue compiler will test to see if the lValue expression was
        complex enough to use reference mode... if not, it reverts to the
        old model of writing directly to the symbols, which is higher
        performance.
	
    4.  Support multidimensional array declarations for DIM and for object
        instance variables.  For example, DIM X[2,3] will create a two-
        dimensional array with two rows and three columns.  Same effect as:
	    
                   X = [[0,0,0],[0,0,0]]
	
    5.  Fix bugs that prevented comma-list multidimensional array references
        from working.  Previously, you could specify X[1][2] but not X[1,2].
	
	    
    July 5, 2008
    ------------
    1.  Fix a number of bugs where attempting to write to a read-only variable
        was either silently ignored or - in some cases - actually allowed.
    
    July 28, 2008
    -------------
    1.  Fix a bug where scope references such as LET X<ROOT> = 33 did not
        work any more.  
        
    2.  Allow scope and class values on nested (reference) values, such as
        LET A.B.C<READONLY> = 55 which creates the record and marks the
        entire record as READONLY (not just the specific record member).
        
    3.  Documented that scope and class values can be on an LVALUE
        anywhere.  For example,  LINE INPUT NAME<PARENT> will input a
        line of text and store it in the caller's symbol table.
    
    4.  Added ASM USING(expr) which causes the expression to be evaluated
        at runtime and assembled and executed, rather than at compile-time.
        The expression can be a single string that is processed just like
        the ASM arguments, or an array of strings where each array element
        is a single instruction.
    
    5.  Added COMPILE(string) function which compiles a single statement
        into an array of byte codes, which can be later used with the 
        ASM USING() construct to execute.
    
    August 4, 2008
    --------------
    1.  Lots of misc. cleanup of badly named variables, spelling errors in
        comments, etc.
    
    2.  Cleanup of server management code.  Fixed gaping hole is management
        synchronization that didn't prevent race conditions properly.  Allow
        SERVER as alias to USERMGR; you can now issue commands like
        
              SERVER START
              SERVER SHOW SESSIONS
        
        which make more sense than the very VMS/DCL-centric SET SERVER form.
    
    August 20, 2008
    ---------------
    1.  Misc cleanup of JBasic, Expression, and Status classes to remove
        unused methods or poor programming style.
    
    2.  Removed LOAD FROM ARRAY syntax, as well as LOAD "name" FROM "file"
        syntax, as neither is needed anymore.  If you need to load a program
        algorithmically, use the NEW USING(x) which accepts a record structure
        defining the program to create.
    
    3.  Allow alternate syntax for specifying storage classes. The following
        are identical in effect.  The V/SCOPE/ format is preferred.
    
    		X<READONLY, COMMON> = 33
    		X/READONLY, COMMON/ = 33
    		X/READONLY, COMMON = 33
    
    4.  Misc cleanup of comments and removing unneeded methods and instance
        variables.
        
    5.  Support PRINT X= notation, which prints the variable name as well as
        a formatted version of the value.  If the value is a string, it is 
        in quotes and normalized.
    
    6.  Fix a bug where relational comparisons on scalar variables could 
        incorrectly change the type of the left-hand variable to the right-
        hand expression.
    
    September 6, 2008
    -----------------
    1.  Fix bug where SAVE WORKSPACE might generate a "SYS$WORKSPACE is a
        read-only variable" error message.
    
    2.  Add LOGINCOUNT field to user record data, which tracks the number of
        successful logins for this user over time.
    
    3.  If the user data has been modified when a server is active, the
        default behavior is to rewrite the saved database XML file when 
        the server is shut down.
    
    4.  Added CSV() function to assist in creating comma-separated-value 
        lists for interchange data file generation.

    September 14, 2008
    ------------------
    1.  Fix bug in retokenizer for some special characters in quotes being
        mistakenly modified with a trailing blank.
    
    2.  Allow an XML root tag to be given when reading via an INPUT statement,
        such as INPUT #1, X AS XML("USERDICTIONARY") which reads the XML block
        and locates a Value with the root tag of "USERDICTIONARY" in the input
        XML.  The default tag is "VALUE" if not given.
    
    3.  Allow PRINT <expr>= notation to use arbitrarily complex expressions
        rather than just limiting it to scalar variables.  The expression 
        reduced to a reference and all secondary references is printed along
        with the result.  This means X[N+3] might print as X[8], etc.
    
    4.  Removed the redundant and ugly retokenizer from the Statement class
        and rely on the ugly retokenizer in the Tokenizer class for this work.
    
    5.  Fixed a bug where the PRINT..= notation did weird and undesirable
        things when an expression like X+3 was given versus a reference to
        a specific value.
        
    6.  Allow ON..THEN GOSUB as well as ON..THEN GOTO, which causes the named
        subroutine to be executed when an error occurs, and then execution
        continues at the code following the error.
        
    7.  Fixed bug where an exception triggered in the middle of a statement
        would leave junk on the execution stack that would cause an error
        on _STMT boundaries.
    
    September 21, 2008
    ------------------
    1.  Change USERMGR statement to SERVER statement, remove alias for SERVER.

    2.  Fix SHELL command to create a unique local symbol table.  The
        SHELL command is currently intentionally not documented.
    
    3.  Change BYE and EXIT to tell user if QUIT will exit shell or JBasic.
    
    4.  Added INPUT..BY NAME(v,v,v) statement.  Added tests for various
        flavors of INPUT operations.
    
    5.  Allow a simple compare for missing value; i.e. "IF X = . THEN..."
    
    6.  Allow INPUT var BY NAME as a variation that stores all the user-
        supplied named values in the variable, leaving it up to the
        program to use the MEMBERS() function and array notation to 
        locate the field values in the result supplied by the input.
    
    7.  When INPUT..BY NAME syntax is used, set the SYS$STATUS variable
        to reflect the status of parsing the input buffer; if there is
        a syntax or similar error, these are set in the SYS$STATUS
        record, and can be used with the MESSAGE() function to evaluate
        or display the error.
    
    8.  Allow string multiplied by integer to be synonym for REPEAT()
        function which creates a string with given number of copies of
        the source string.  So "X"*3 is "XXX".
    
    September 28, 2008
    ------------------
    1.  Updated DATE() function to accept an optional second parameter
        containing the format specification (passed directly to the
        java.text.SimpleDateFormat class).  If the first parameter is
        zero or "TODAY" then it assumes today.  If the first parameter
        is a number, it formats as a string.  If the first parameter
        is a string, it is parsed to locate a valid date using the
        format pattern as a guide.
    
    2.  Fix bug where XML program files would not load correctly.
    
    3.  Allow CLEAR command to accept a comma-separated list of items
        to clear, as in CLEAR PROGRAM FOO,BAR
    
    4.  Add SAVE PROTECTED "file.ext" to save the current program as
        a protected XML object in the named file.  Same basic function
        as SAVE XML but saves the BYTECODE() value of the file rather
        than the PROGRAM() value of the file.
    
    5.  Bug fix where immediate mode command containing only a
        special character would trigger a Java error.  Fix bug where
        load of protected XML with linkage maps would sometimes fault.
        Fix bug where loaded XML programs were incorrectly marked as
        unsaved.
    
    6.  Fix bugs in ARRAY declaration statement so initial values
        are not themselves arrays, and an ARRAY of a value that was
        already a larger array has the correct number of elements.
    
    October 4, 2008
    ---------------
    1.  Add IN operator, similar to the SQL operator, such that 
    
               X IN (list)
        
        is true if the value x is present in the list.  This can be
        used to quickly find if an item is in a list, and will
        ultimately be more optimal than using the LOCATE() function 
        to see where an element is located in an array.  Part of this
        is because the IN operator optimizes for constants.
        
    2.  Add array constant pooling. If an array constant is found in
        the program, then a constant value is stored in a hidden
        symbol (__ARRAY$id) and all future stack loads for this 
        constant are converted to references to the pooled value.
        Note that the IN() list above is also stored as an array
        constant if possible.
    
    3.  Same for records; these are now pooled as well, under the
        symbolic name __RECORD$id).
        
    4.  Changed SHOW SYMBOLS so that it doesn't show names that
        start with "__" which are considered invisible.  This 
        means that things like file #3 is no longer also seen
        as a symbol "__FILE_3".
    
    5.  Fix bug in CHAIN statement that resulted in the original
        program resuming execution after the CHAIN program completed.
    
    6.  Connect constant and array pooling to the SET POOLING flag,
        which also controls attempts by the optimizer to locate
        constants not caught during compilation.  This is off by 
        default; the constant has to be pretty big for the payoff
        for pooling to offset the cost of symbolic lookups.
    
    October 12, 2008
    ----------------
    1.  Support nested Status() objects, so cascading errors can
        be reported.
    
    October 31, 2008
    ----------------
    1.  Add SET LOGGING=n command to set the log level for multi-
        user mode.  This also sets the read-only system variable
        SYS$LOGLEVEL.  Default is 1 which is warning and errors,
        can set to 2 which includes info or 3 which includes
        debugging stuff. Not available for use by remote sessions.
        
    2.  Add logging for user session connection, disconnection,
        login failure, and permissions failures.
    
    3.  Fix bug where EXISTS() function wasn't multiuser-aware.
    
    4.  Fix bug where KILL wasn't multiuser-aware.  Also fixed
        bug where KILL would not report errors properly when a
        KILL for a nonexistent file was requested.
    
    5.  Add TYPE as a built-in verb that types the contents of
        an external physical file.
    
    6.	Experimenting with optimization for CHR$/CHARACTER
        function.  During compile phase, it examines the code
        that sets up the argument list, and if it is the simple
        case of CHR$(i) where i is an integer constant, it
        replaces the _INTEGER with a _STRING and generates no
        additional code.
    
    November 4, 2008
    ----------------
    1.  Fixed a ton of bugs related to invalid string->numeric
        conversions.  For example, COS("ABC") would signal a
        Java NumericFormatException error.  
        
    2.  Fixed bug in the _STRING n optimization previously
        pushed.  Must signal UNKFUNC if compile() method
        cannot complete successfully, if you want proper call
        generated to the run() method.
    
    3.	Cleaned up a few redundant chunks of code so existing
        methods are better used.
    
    November 11, 2008
    -----------------
    1.  Closed security gap where FILETYPES() and similar functions
        could see into native file system when relative path
        strings where used when in sandbox mode.
        
    2.  Closed security bug where some global symbols were not
        correctly set to read-only.
    
    3.	Detect when attempting to start server on a port already
    	in use, and report error before creating Telnet daemon 
    	instance.
        
    November 25, 2008
    -----------------
    1.  It has been suggested that DO..WHILE and DO..UNTIL should
        evaluate the expression and determine if the loop should run
        at all.  This is pretty easy to arrange by having the leading
        _DO contain a forward branch reference that the linker fixes
        up to the conditional code, which is used as an initial branch
        when the _DO is first encountered.  Subsequent _LOOP stack
        handling branches back to the instruction following the _DO.
        Currently this has been changed to be unconditional; i.e. the
        condition is always tested before the loop runs even once.
        Thanks to Bill Chatfield for the suggestions.
        
    2.  I can't quite decide if DO WHILE cond .. LOOP should behave
        differently than DO .. WHILE cond.  One approach is that the
        placement of the condition describes where it is done in the
        loop; i.e. DO WHILE tests at the top of the loop as opposed
        to DO..WHILE which tests at the bottom of the loop.  The other
        is to assume that the loop expression is meant to describe the
        same logic regardless of syntax.  
        
        So for right now, you can control this behavior yourself.  
        By default, putting the condition on the DO statement means 
        it evaluates at the top and the loop may not run at all. 
        Putting the condition at the end means the loop will always 
        run at least once. If you specify the option statement 
        SET LOOP_OPT, this enables loop optimization, and the two 
        forms become identical; the condition is always tested
        before the loop ever runs. 
        
        Use SET NOLOOP_OPT to turn this mode off and have the 
        default behavior again.  Note that this switch is only checked
        at link time, so changing it will require a LINK command on 
        any program that has already been linked or run to change its 
        behavior.  
        
        Further testing  and use may tell me more about the correct 
        default setting of LOOP_OPT.
    
    November 30, 2008
    -----------------
    1.  Add MKDIR() function, which creates a directory given a path.
        The function returns true if the directory was created, else
        false if it already existed. An error is signaled if the path
        is invalid.  
    
    2.  Modify SERVER START to validate and create if needed all the
        directories specified as user home directories or logical name
        locations.
        
]CHANGES 2.5
New release notes start here.

    December 1, 2008
    ----------------
    1.  Changed version number to 2.5, having just posted official 2.4
        release package to SourceForge.
    
    2.  More javadoc updates.  Eventually all the functions and byte codes
        will be properly documented.
    
    3.  By default, logical names for _TMP, TMP, and _WS are created to
        define private and public temporary areas and the private workspace
        storage area.  These are always in the "jbasic" sub-directory of the
        user's temporary directory location by default.  This can be 
        overridden by creating the logical names explicitly.
    
    4.  When a new user is created, by default the workspace name is always
        in the _WS:: logical path, and has a name that contains both the
        user's name and a unique ID value.  This allows all the workspace
        files to reside in one directory without fear of collision and/or
        discovery, since directories with leading "_" characters in the
        logical name cannot be read by FILETYPES() and similar functions.

    December 3, 2008
    ----------------
    1.  Fixed bug in refactoring of LoopManager (done in previous release)
        that broke FOR..DO statements.
        
    2.  Attempt to create relatively unified Javadoc for the functions. 
        Because there is so much to do to clean up the Javadoc, I'm
        removing it from the revision temporarily.  You can always 
        generate your own Javadoc using the supplied javadoc.xml file
        from any release of the source code.  Once the Javadoc is much 
        more stable, I'll regenerate it and put it back as part of the
        source bundle.
    
    3.  Better handling of "ALL" permission.  When revoked, permissions
        are all removed from the list. When granted, all  permissions
        are put in the list.  List is now returned in sorted order 
        for easier readability.
    
    4.  Added OPEN PIPE "command" AS FILE FOO syntax.  The command must
        be a native command in the host environment.  The command is 
        run as a subprocess and the output is directed back to the file 
        descriptor. Pipes are bidirectional; you can create a pipe that 
        you write to as well as read from. However, be careful, this 
        can deadlock your program if you wait on input from the pipe 
        and the piped command is waiting on input from your process.  
        Consider using JBasic threads to handle pipes if synchronizing 
        input and output is a challenge.
        
    December 8, 2008
    ----------------
    1.  Fixed numerous problems in BINARY file character handling that 
        prevented JBasic from being able to read files created outside 
        the JBasic environment.  Character data was being written and 
        read as UNICODE characters instead of bytes.  Additionally, 
        JBasic was writing and reading a length parameter in the string 
        data, which (overly) helpfully supported varying length strings.
        This has been corrected.
    
    2.  Added new BINARY data type of VARYING, which is a varying length
        string that has an integer length before the string data.  This 
        can support varying length strings created by JBasic but cannot
        be used to read externally-created strings unless they conform
        to the same format, including the leading 32-bit length field.
    
    3.  Require a length specification to indicate how large the STRING
        or VARYING field is.  This was previously considered optional, 
        but I think it must be required now to make sure that BINARY 
        file data records can be uniform.
   
    4.  Added FLOAT and UNICODE data types for BINARY file I/O.  UNICODE
        works like STRING and VARYING (and requires an explicit size)
        but writes UTF-16 Unicode data to the binary file.
    
    5.  A teaspoon of syntactic sugar; you can specify VARYING STRING
        and UNICODE STRING as the types if you wish.  That is,  VARYING
        and UNICODE types can have an optional keyword STRING after them
        to make the code more readable.
    
    6.  Allow varying sizes of INTEGER and FLOAT. You can specify 
        INTEGER(1), INTEGER(2), or INTEGER(4) to specify a byte, word,
        or longword value.  INTEGER(4) is the same as INTEGER with no
        size.  Similarly, FLOAT(4) is a single-precision value, and
        FLOAT(8) is a double-precision value.  FLOAT(8) and DOUBLE are
        the same thing.
        
    December 11, 2008
    -----------------
    1.  Added FIELD statement.  This has the same format as the RECORD
        statement, except you give a file ID rather than a variable 
        name.  The record is stored in the FILE ID itself, making this
        an executable statement that can dynamically change the current
        record definition.  When a GET or PUT statement is given with
        no additional arguments, it implies that the FIELD definition
        is to be used.
    
    2.  The FIELD statement can be used in place of a RECORD statement
        as well by specifying an identifier name rather than a file
        reference.  The FIELD statement automatically sets the SIZE
        record entry for INTEGER and FLOAT values if not given explicitly.
        It also allows an "AS" keyword between the type and name, such
        as INTEGER(2) AS ID.
    
    3.  Changed the unit tests to use the FIELD statement rather than 
        the RECORD statement.  I think the RECORD statement should be
        phased out in favor of the FIELD statement; it's more like other
        BASIC languages and helps prevent confusion with a RECORD data
        type.
    
    4.  SEEK is now aware of implicit FIELD specifications; if there is
        one active then a SEEK will automatically use the FIELD data 
        to scale the seek operation.  if a USING clause is given, that
        overrides the default FIELD, just as in PUT and GET.
    
    5.  Allow CLEAR FIELD <file> to remove the FIELD specification (if
        any) from the given file reference.
    
    6.  Allow FIELD <file spec> USING <field-name> to assign an existing
        FIELD object definition to a given file.  This allows the FIELD
        to be created before the file is used, and then assigned to the
        file after it is open.  TEST$FILE08 updated to demo this.
    
    December 14, 2008
    -----------------
    1.  Allow "#" file reference syntax for identifiers as well as integer
        file references. This makes programs more compatible with other
        dialects.  For example, PRINT #BD, NAME$  where "BD" is a file
        identifier.  Note that - right now - you cannot use expressions
        for file references.  This should be reconsidered for the future,
        to change LOADFREF to handle an expression on the stack and
        to synthesize a file reference accordingly.
    
    2.  Improved error handling in the OPEN statement compiler to detect
        duplicated clauses.
    
    3.  Improved error handling in CALL statement for duplicate clauses.
    
    4.  Improved error handling in BREAK statement for duplicate clauses.
    
    5.  Modify DATA statement to only allow constants, not expressions.
        There are too many ways this was able to go wrong, and it's not 
        clear that there is any significant value since the expressions 
        couldn't reference a symbol anyway.
    
    6.  Disallow duplicate names in DIM or COMMON variable lists.  This 
        isn't technically illegal, but almost certainly indicates a 
        programming error.
    
    7.  Disallow the possibility of inserting a  statement in a protected
        program.  Removed constant error message text from Statement method
        while I was in there.
    
    8.  Cleanup syntax error messages in statement compilers, so they 
        only use localizable Status() messages rather than string 
        literals for error messages.
    
    December 27, 2008
    -----------------
    1.  More message cleanup; rooting out constant strings where possible.
        For some FAULT errors that indicate massive internal failure, I'm 
        not worrying about localized messages.  But most messages are now
        localizable.  Also, added some constant strings to the message file
        that should be localized. 
        
    2.  Added better argument checking for opcodes where the integer is a
        selector value.
        
    December 31, 2008
    -----------------
    1.  Added (user requested) multi-line IF-ELSE-END IF statement syntax.
        The statements each generate variations of the _IF bytecode, which
        are used as markers to the linker to patch in the appropriate 
        true and false block branches.  
    
    2.  Updated user doc and online help accordingly.
    
    3.  Fixed bug in CLEAR PROGRAM that was incorrectly reporting a bogus
        bytecode operand even after successfully deleting the program.
    
    4.  Fix bug in linker; the statement label map was not being correctly
        updated in some cases when instructions where deleted, resulting in
        bogus branch destinations.
    
    5.  Modified VERB$HELP to use the new multi-line IF statements.
    
    
    January 4, 2009
    ---------------
    
    1.  Allow DO..LOOP with no conditions, which creates an (intentional, 
        we hope) infinite loop. 
        
    2.  Added CONTINUE and END LOOP statements which cause a loop to 
        restart at the top of the body or to branch out of the loop past
        the end of the body, respectively.
    
    3.  Improved error handling in the linker to catch mal-formed DO..LOOP
        and FOR..NEXT constructs.

    4.  Allow SUB to define a local subroutine.  This is executed in every
        way as if it was in a separate program, but is really contained in
        the current program. When a CALL statement is executed, the named
        program is first searched for in the local program, then an external
        program is searched for.  The same mechanism is used when searching
        for a function to call; if there is a SUB of the name, then this is
        called as the local function (and must return a value!)
        
        This is for better compatibility with other dialects of BASIC.
    
    5.  END LOOP and CONTINUE resolved by the Linker instead of at runtime,
        allowing better branch optimizations.  Also fixed bug where CONTINUE
        did not work correctly when DO..LOOP expressed condition at the top
        of the loop.
    
    6.  Fix bug where END LOOP couldn't be used in a FOR-NEXT loop.
    
    January 17, 2009
    ----------------
    1.  Doc cleanup.  Fixed some issues in the online help, and did some
        general technical editing on the User's Guide document.
    
    2.  Started using Apple's SHARK performance tool with Java to do some
        profiling. Immediately learned that the isReadonly() method for
        symbols was chewing up time like crazy because it was called for
        objects that didn't exist, and threw an exception which was VERY
        expensive.  Just cleaning this up caused the default benchmark
        program (very variable intensive) to speed up about 20%.
    
    January 22, 2009
    ----------------
    1.  Additional minor tweaks to the runtime environment for performance.
    
    2.  Fix a problem where the name of a program could not be the same
        as any function it calls.  For example, PROGRAM XML meant you could
        not call the XML() function.  This is because _ENTRY items are
        stored in the link map for use when _CALLF tries to use a SUB local
        function.  However, we should only put items in the link map that
        can actually be called this way (i.e. a SUB entry is recorded,
        but not a PROGRAM entry).
    
    3.  Add ability to specify both PORT number and LOGGING level on the
        SERVER START command.
    
    4.  More Shark profiling reveals excessively cumbersome String
        management when copying a value (used heavily at runtime
        when removing a value from the stack that will be updated).
        Also, convert the map of open user files from a TreeMap to
        a HashMap for better performance of file-intensive programs
        such as the HELP command.
    
    5.  Cleanup of various indirect method invocation operations for
        dispatching function compile and run methods, etc.  Basically
        removing over-use of reflection when the method names are
        in fact static and well known.
    
    February 2, 2009
    ----------------
    1.  Added online help entry to describe the $MODE variable. This
        needs to be put in the user's guide as well.
        
    2.  Convert LOAD statement to compile/execute rather than 
        interpreted command.
    
    3.  Time to lock down the 2.5 release for distribution via a
        package at SourceForge.  Only defects will be fixed from
        here on until 2.5 is release, with a target of mid-Feb.

]CHANGES 2.6
The new release features for 2.6 are documented here.  The primary
focus of this release is adding support for direct manipulation of
Java native objects.

    February 9, 2009
    ----------------
    1.  You can define a program to be run automatically by a remote
        telnet connection.  This program must exist in the library
        as opposed to a work space.  Use the syntax
        
            SERVER START SHELL="program-name"
        
        By default, a user name is created that matches the program
        name and defines the default working directory, etc. for the
        program. You can explicitly create this name if you want to
        give it more than the minimum privilege set.  When a server
        is started in this mode, the telnet connection is made to 
        an instance of JBasic without requiring a user name or password
        connection... instead an instance of the program is started
        for the telnet connection. When the program exits, the 
        telnet connection is dropped.
     
    2.  Started restructuring SERVER statement.  It was too cumbersome
        to edit, so each sub-statement is its own method.  Each one is
        being restructured to generate code rather than interpret it.
        
    3.  Started on user request for direct Java object access.  This
        will involve several phases.  This first part involves creating
        Java objects using the NEW() function and manipulating public
        fields in the object.  NEW() when called with a string argument
        assumes that is a class name, and creates a new instance of the
        class.  The resulting Value has many of the characteristics of
        a RECORD, but the members are actually field names. Since JBASIC
        is case insensitive, all field names are converted to uppercase,
        which means that aField and AField will be ambiguous - not
        yet sure how to handle this.  Object nesting works, so A.B.C
        will set field C of object B in object A.
        
        You can print a Java object, but nested objects are printed
        as OBJECT(class.name) rather than recursively formatted. This
        is because there are no rules in Java to prevent referential
        loops, and the recursive formatter would stack-crash.
        
        This is all implemented by a new Value type of ObjectValue,
        which is a subclass.  It does not permit some operations such
        as using the entire object in an expression; only the members
        can be referenced in expressions.  This was moved to a new
        package (org.fernwood.jbasic.value) because eventually the
        Value object itself will need to be refactored into discrete
        types.  However, this is a way off since there are cases where
        the object handle is retained regardless of type (referential
        expression objects on the stack) that will need to be re-
        evaluated in the context of refactored Values.
        
    4.  Started adding signaling to the Java object handling code,
        so ridiculous or illegal operations are caught when attempted
        on a Java object value.
    
    5.  Added method invocation and return value processing using the
        CALL A->METHOD() RETURNS X format, which will calls the named
        method on the object, and puts the result in variable X.  If
        the method does not return a value, then do not use the RETURNS
        clause.  Note that method names (like field names) can be
        ambiguous; Java is case-sensitive and JBasic is not.  So if you
        have two ambiguous method names, JBasic will call the first
        one found in the method list.  This should probably be handled
        as a warning in the future if possible.
        
        Note that for methods that return a value, you can also use
        the notation A->METHOD() in an expression.  This is detected
        as a special case of a method invocation rather than a JBasic
        object member lookup operation.  In this case, the method MUST
        return a result or an error occurs.  This syntax is also now
        permitted for JBasic objects as well as Java objects.  If the
        method takes no arguments it must still have an empty argument
        list or it will be processed as a JBasic object field reference.
    
     6. Static object fields are referenced with a leading "_" in the
        field name.  This means that static fields do not show up in 
        a normal display of the object, but can be referenced as long
        as the name is prefaced with "_".  This is to prevent clutter
        while examining objects.
        
     7. It should be noted that JBasic wrappers on Java objects are
        *huge*.  That is, there are two RECORD structures and a HashMap
        created to support information about how to access the object.
        So a simple string can balloon to 1k or more of storage.  In
        short, only use these when you need them; if at all possible
        use JBasic constructs instead. For example, don't create a
        HashMap to keep a list of key values, use a JBasic record
        instead because it is much faster and more space-efficient.
     
     8. Added OBJECTMETHODS(obj) function to return an array of valid
        method calls available on the given wrapper Java object.  This
        throws an error for a type other than a Java object.
     
     
     February 20, 2009
     -----------------
     1. Improved error handling for bogus method calls.
     
     2. Better handling for the case where a specific object value 
        is passed to the method but the method needs a more generic
        object, such as passing items into a java.util.Vector.
     
     3. Better handling of return values from objects that are
        arrays; the array is returned as a JBasic array of values.
     
     4. Require JAVA permission in remote mode to access addObject()
        session method or call the NEW() function to create a Java 
        object.
     
     5. Misc security improvements to prevent user from injecting 
        insecure path locations into various load maps or modifying 
        sandbox mode from within a JBasic program.
     
     6. Improved error handling from method invocations that throw 
        Java errors or do not correctly return a value when expected.
     
     February 25, 2009
     -----------------
     1. Misc cleanup of internal methods, misspelled comments, etc. 
        Sometimes you need to clean your room to feel happy.
     
     2. Fixed annoying bug where unused input from an INPUT statement
        was left in the read-ahead buffer, and  would be interpreted 
        as the next command input when the shell took control again 
        for a new command or statement.  Now, the shell checks for 
        this case and warns the users that unused text was found but 
        discarded.
     
     March 2, 2009
     -------------
     1. Added improved type checking on object calls; two methods 
        with the same name but different parameter signatures can be 
        called correctly if the JBasic argument lists match the
        signature. So method calls of X->SETVALUE("STRING") and 
        X->SETVALUE(11) can be  different methods with String and 
        int parameters, respectively.
     
     2. Calling NEW() with a string first argument (Java class name)
        and additional arguments calls the object constructor with 
        matching argument types, just like a normal method call uses 
        the parameter types to form a signature.
     
     3. Improved error reporting when a JBasic method invocation can't 
        be matched to an actual Java method signature; the reported error 
        shows the signature being looked for based on the actual JBasic 
        argument parameters.  The caller can often use type coercion 
        functions to help with signature matching.
      
     4. Add new SET [NO]PACKAGE="partial-path-string" which adds or 
        deletes partial path strings from the SYS$PACKAGES array. 
        This is used to qualify class names for loading user-written 
        statements or functions, and also for fully qualifying class 
        names passed to NEW().  If the class name is valid as given, 
        it is used as given.  But if it isn't a full class name, the
        list of package paths in SYS$PACKAGES are tested to see if any 
        results in a valid path name.  The first one found is used.  
        Changing the SYS$PACKAGES list requires the "JAVA" privilege
        for remote or sandboxed users
     
     5. If a method to a Java object returns a JBasic value, it is 
        now correctly returned as the actual value, not a JBasic 
        object wrapper on the value. This is particularly helpful 
        when user-written classes are intended to return values 
        directly back to JBasic.
     
     6. Fix a few bugs in marshaling between primitive types and 
        their object wrappers on parameters to method calls.
     
     7. When a value is an object and it is printed, don't use the 
        RECORD format but instead call the underlying toString() 
        method.  Also, change the way SHOW SYMBOLS displays objects 
        in the symbol table; the class is listed along with the 
        toString() value.
     
     8. Allow SET [NO]PACKAGE to accept an array of strings as 
        well as a string value.  Other data types are not allowed.
     
     9. Allow external programs (using JBasic in an embedded mode)
        can call getObject() on any Value.  If the Value isn't a
        wrapper object, then a null is returned.
     
     March 10, 2009
     --------------
     1. Fix bug preventing edge-condition detection in BREAK WHERE
        statements; the event was triggered each time it was true
        if a RESUME command was used.
        
     2. Allow RESUME RESET as a variation of RESUME that intentionally
        resets the breakpoint edge detection so the very next instance
        where the condition is true will result in a break.
     
     3. Fix bug where STEP wouldn't display statement text for programs
        with no line numbers.
        
     4. Improved formatting of SHOW CALLS to properly align statements,
        and also show the $MODE for each call frame.
     
     5. Allow a program to be called as a function, even when it has the
        PROGRAM versus FUNCTION header.  The order of precedence for a
        function call is a user FUNCTION, a built-in function, or a 
        PROGRAM that matches the function name being called.  The $MODE
        variable is set to "FUNCTION" when a program is used this way.
     
     6. Allow DIM and COMMON to specify the type before the variable name
        in addition to the current AS <type> clause.  So the following
        are equivalent:
        
            DIM X(5) AS INTEGER
            DIM INTEGER X(5)
     
     7. Allow a user-written FUNCTION to declare a specific return type
        for the function. Any RETURN statement the the function will 
        automatically have the result coerced to the given type.
        
            FUNCTION MYDOUBLE(X) RETURNS DOUBLE
            
        Will always return a DOUBLE, even if the RETURN statement attempts
        to return another data type. An error will return if the RETURNED
        type cannot be coerced to the expected RETURNS type (a record cannot
        be coerced to a boolean, for example).
        
    March 15, 2009
    --------------
    1.  Fix ARRAY declaration statement to require an array size and do
        correct type coercions when RECORD constant given.
    
    2.  Correct error message when NEXT statement does not specify an
        index variable.
    
    3.  Fix bug where _STORALL (used by array initialization) didn't 
        store a different Value in each cell, but instead stored a
        reference to the same value in each cell.
        
    4.  Fix bug where you could add or delete statements from a running
        program under the debugger.  Fix bug where RESUME could throw a
        null pointer exception after debugger exit.
    
    5.  Errors incurred in the debugger command shell should not stop the
        debugger, just be reported like the regular command shell.

    6.  Clean up some sloppy syntax handling in PRINT with file clauses.
        Also, display pipe command as file name in PIPE file record.
    
    March 17, 2009
    --------------
    1.  Clean up DATA/READ/REWIND operations.  REWIND requires a valid
        line number or label. READ throws an error when at EOD.
    
    2.  A DELETE statement to remove lines of code was not unlinking
        the program.  This has been corrected.
    
    3.  CALL AS THREAD accepts an optional lvalue in parenthesis where
        the thread id is stored.  For example,
        
            CALL PI_TEST() AS THREAD(X)
        
        Runs the routine PI_TEST on a thread, and puts the name of the
        thread in the variable X so the calling program can reference
        it later for completion, etc. using the THREAD() function.
     
     4. EXECUTE "command" AS THREAD(X)  will run any arbitrary JBasic command
        on a new thread, and stores the resulting thread name in the 
        variable X.
     
     5. Clean up error messaging when commands like LINK or LIST are 
        given and there is no current program.  
        
     6. Cleaned up a few THREAD and SHOW commands that were supporting 
        other statements, but could just be compiled directly. An example 
        was CLEAR THREADS which executed THREAD RELEASE which generated 
        a short code segment, which could just as easily have been done 
        in the CLEAR statement compiler.
     
     7. Fixes for THREAD LOCK and UNLOCK.  You can now only unlock a LOCK 
        that you hold.  The LOCKS() function returns an array of records
        describing each lock.  SHOW LOCKS can display this information on
        the console.  You can pass the output of LOCKS() to the THREAD
        UNLOCK statement and it will unlock the locks you hold.  Locks
        held by a thread are automatically released when the thread exits.
        CLEAR LOCK can be used to delete a lock.
     
     8. The THREAD LOCK and THREAD UNLOCK are broken out as separate LOCK
        and UNLOCK statements, each of which takes a list of lock names
        (not string expressions). UNLOCK ALL LOCKS will release all locks
        held by the current thread.  Added a unit test LOCK1 to demonstrate
        use of locks.
     
     9. Each lock has an owner (the SYS$INSTANCE_NAME of the session) and
        you cannot delete a lock that is owned by another thread.  When a
        thread dies, if there are locks it owned that are held by someone
        else (there is active interest in the lock) then the lock is put
        in a "zombie" state where the next thread to use the lock will
        become its new owner.  This prevents malicious user programs on
        threads from deleting locks and potentially corrupting execution.
    
    10. Allow LOCK USING(string-expr) and UNLOCK USING(string-expr) to
        specify a string expression rather than a lock identifier name.
        Modified _LOCK to handle a create flag as the instruction argument,
        so no _LOCK/_UNLOCK sequence is required to create a new lock.
        Also, fix synchronization problem on releaseAll() in the lock
        manager on thread termination.
    
    11. Fixed bug where remote user shell termination did not correctly
        release held locks.  Also corrected problem where a lock released
        by thread or shell termination (a zombie lock) wasn't being
        correctly claimed by the next thread to try to hold the lock.
         
    March 22, 2009
    --------------
    1.  Remove SET GWBASIC compatibility mode.  This was always on by
        default, and the only case where you would really want it off
        is to enable the otherwise-reserved variable names RND and MID$.
        However, it slowed down expression compilation and otherwise
        had little benefit. Now, GWBASIC mode is essentially always on.
    
    2.  Add caching to DATA statement mechanism. The first time a DATA
        element is read, the byte code associated with it is run. This
        means that no penalty is incurred for DATA not read.  However,
        a subclass of ByteCode for DATA adds a cachedResult field, which
        holds the results of each READ.  Subsequent reads of the same
        data return the cached value.  The cached value is discarded
        when the DATA vector is deleted. This can result in more than 4x
        speed improvement when DATA containing arrays or records is
        read more than once.
    
     3. Fix bug (really, undo previous optimization) that tried to
        discourage unwanted copies of stack items... there are cases
        where the datatype and operation will require a copy anyway
        because of how type coercion works at runtime.  This was
        discovered with the simple test
        
            FOR I = 1 TO 100
               LOCK USING("LCK_" + I)
            NEXT I
        
        The expression to form the lock name was changing the type
        of variable I to a string, which broke the FOR..NEXT loop
        processing.  This has now been corrected.
     
     4. Allow source line continuation using a single backslash "\"
        as the last character on the line.  The next line is appended
        in place of the backslash.  Multiple continuation lines are
        allowed.  When a file is saved, it will have continuation
        characters inserted if the line is longer than the global
        variable SYS$SOURCE_LINE_LENGTH which has a default of 132.
        Updated the ELIZA program using continuation characters to
        make the data table at the end much more readable.
      
     5. Fix bug that caused unknown verb followed by a dot to throw
        an error.  Now reports it as invalid member syntax (presumed
        to be the start of an implicit LET).
     
     6. Fix bug in FILETYPE() where path name was returned incorrectly.
     
     7. Fix bug in FILES command where invalid command syntax was not
        handled correctly.  Also, correctly handle "~" prefix when a
        remote user.
     
     8. Message data is now local to a session.  When a new JBasic 
        session is created, it may have a parent or not.  If there
        is no parent session, then the $MESSAGES file is loaded into
        the current session's MessageManager instance.  If there is
        a parent session, then the parent's message database is copied
        to the child.  Messages that are added by threads, for example,
        are scoped to the thread instead of leaving messages in a global
        message database.
     
     9. Add SLEEP command that accepts number of seconds (integer or
        floating point) to suspend the current program thread.  Values
        of zero or less cause no sleep interval to occur.
    
    10. Cleaned up a few things in recently-added tests, to ensure that
        queues, locks, and threads are all deleted cleanly when the
        tests complete.  Add a new test THREAD1 that is the old thread
        test program packaged as a self-validating test of threads and
        queues.
        
]CHANGES 2.7
The new release features for 2.7 are documented here.

    April 13, 2009
    --------------
    1.  Modify the Value class to consolidate all the object types into
        one Object field.  BOOLEAN, INTEGER, and DOUBLE continue to be
        stored as scalars in the Value, since creating object wrappers
        for them costs 8-10% performance.  Cleaned up accessor functions
        so you cannot directly manipulate the Value fields, allowing me
        easier freedom in further modifications to factoring out the
        Value class where possible.
    
    2.  Remove the costly popForUpdate() for source arguments to diadic
        operators by changing the coerceTypes() call to just find the
        best type and only coerce the target value.  This adds 5% or so
        in performance.
    
    3.  Overload fillInStackTrace() in the JBasicException class since
        such exceptions don't need a stack trace and the operation is
        quite costly.  The overload is an empty method.  Adds 1-2% gain.
    
    4.  Minor optimization to _BRZ and _BRNZ since the case of no
        destination address is no longer used.
   
    5.  Change most instances of Vector<> to ArrayList<> since we 
        don't need the synchronized quality of Vectors.  Since this
        included many of the cache lists and such, this results in 
        a 5-8% performance gain depending on test job.
    
    April 15, 2009
    --------------
    1.  Fix bugs where an incomplete SERVER START (for example, default
        user data base file not found and no users explicitly defined)
        was resulting in a null pointer error tearing down the partially
        functional server.
    
    April 20, 2009
    --------------
    1.  Allow SHOW VERB PRINT to show the user that PRINT is a built-in
        verb.  This works for any built-in verb or verbs in packages
        added by the user.  The output also shows if the verb compiles
        to ByteCode or is interpreted.
    
    2.  Ditto for SHOW FUNCTION SUM which shows that it is compiled in
        to the code stream, and SHOW FUNCTION SIN which shows that it
        is a run-time function provided by the language.
        
    May 16, 2009
    ------------
    1.  General cleanup to the JBasic class, changing visibility and
        adding accessor functions to reduce unwanted class exposure.
        
    2.  Modify XML parsing to allow <ARRAY> and <RECORD> tags without
        an explicit count.  This slows down parsing slightly but makes
        it easier to algorithmically generate XML.  Also, allow short
        form of scalar tags, so the following are equivalent:
        
             <INTEGER> 35 </INTEGER>
             <INTEGER DATA="35"/>
    
    May 25, 2009
    ------------
    1.  Fix bug where negative integer and floating point values did
        not parse correctly in the long-form XML format.
    
    2.  Allow conditional subexpressions.  For example, 
    
            PLURAL = "ITEM" || IF COUNT <> 1 THEN "S" ELSE ""
    
        There must be both a THEN and an ELSE clause.  In this
        case, a subexpression of the concatenation operator will
        evaluate COUNT and use either "S" or "" as the value to
        concatenate.  The IF <test> THEN <expr1> ELSE <expr2> can
        appear anywhere an expression can be used.
        
        Updated FILES and FIND commands to demonstrate use of this
        construct in expressions or PRINT statements.
    
    3.  Fix bug where DIM of a multi-dimensional array would create
        arrays all referencing the same element.  When a subsequent
        statement to set the value used the _SET opcode, this changed
        all elements to the new value.
    
    4.  Allow SLEEP statement to specify units after the numeric value,
        such as SECONDS or MILLISECONDS.
    
    5.  Disallow reserved verbs as variable names; it causes too many
        problems.  So you can no longer say IF = 3 to set an integer
        variable named "IF".
    
    June 3, 2009
    ------------
    1.  Add post increment and decrement operations with "++" and "--".
        Note that "x++3" is an error because the "++" is taken as a post-
        increment, while "X + +3" is adding positive 3 to X.

    2.  Likewise add pre-increment and decrement operations, which can
        only be followed by individual variables that can be case as
        integers or doubles (i.e. ++X where X is an ARRAY generates a
        runtime error).  Add new INCREMENT1 unit test.

    June 21, 2009
    -------------
    1.  Update the ELIZA verb to use data tables at runtime rather than
        re-reading DATA statements for the response maps.  Move the edit
        maps to an array as well. Allow LOAD DATA and SAVE DATA commands
        in ELIZA to load/store XML representations of both maps.  A single
        parameter to ELIZA is the filename to load on startup.
    
    2.  Fix bug in _ADD that was incorrectly storing reference to addend
        rather than copy of addend when target was array or record.  This
        could cause - among other problems - recursion loops that crashed
        JBasic.
        
    June 29, 2009
    -------------
    1.  Allow statements that have compile-time errors to be stored in the
        programs.  Previously, these statements were discarded.  Now they
        are stored anyway, but attempts to LINK or RUN result in the compile
        error being (re-)printed as a reminder.
    
    2.  Paired with #1 is improved error reporting at LINK or UNLINK time of
        compile errors in statements.  
        
    3.  Added Status() constructor that accepts code with parameter AND a
        nested status.  This lets the LINK error report the original compile
        error fully.
    
    4.  Fixed dumb bug that prevented IF..THEN statements from compiling in
        some cases.
    
    5.  Allow NEW FUNCTION or NEW PROGRAM to include declaration of parameters
        in the NEW statement, which are copied to the generated PROGRAM or
        FUNCTION statements in the newly-created programs.  Incorrect parameter
        syntax still results in the function or program being created, but 
        they must be fixed before it can be run.

    July 9, 2009
    ------------
    1.  Minor error messaging cleanup in XML parsing when data type is not
        known.  Also, discontinue including COUNT= in the XML for <ARRAY>
        tags.  While slightly faster to parse, they make editing the XML
        much more cumbersome.
    
    2.  A database file has a field in the file handle called QUERY which
        contains the text of the current active query.
    
    3.  Fix some problems with REFSTR operations; i.e PRINT X[Z[1],2]= where
        the trailing "=" causes the expression to be printed as well as the
        result. However, there are still remaining problems in the formatting
        of nested index expressions that need further attention. [BUG]
    
    4.  Fix problem where an _INDEX operation would recast the source value
        to an array.  So LET X=3, Y=X[1] would result in X becoming an array.
        Now, an error is thrown when indexing a value that isn't already an 
        array.

    5.  Allow SHOW HIDDEN SYMBOLS to display only the hidden symbols, such
        as constant pools or numeric file references.
        
    July 20, 2009
    -------------
    1.  Add CLASS() function which returns native Java class for any argument.
        If the argument is a native JBasic type, the native type is returned
        such as "int" or "java.lang.String".  If the argument is a Java object
        in a value wrapper, the underlying Java type is returned.
    
    August 5, 2009
    --------------
    1.  Cleanup the SORT verb so it reports when an empty array is sorted
        by a key value as an error.  Also, use a nested return code to report
        the offending row when a row in the array of records is found to be
        missing the key.
    
    2.  Improve the conversion of a Status to a Value; the nested status is
        now always stored as a SUBSTATUS record in the value, rather than
        previously where it was in the PARM slot.  This allows a code to
        have both a parameter and a nested sub-status.
    
    3.  Improved checking and error reporting when instructions have bogus
        statement labels or line numbers in them, such as REWIND or GOTO.
    
    4.  Fix bug where loop stack was not maintained properly across call to
        local SUB routines.
    
    5.  Rename CLASS() to CLASSOF().  Rename JAVACLASS() to CLASS().  Update
        SHOW FUNCTION dictionary and online help.
    
    6.  Improved error reporting if you try to use CALL() on a compile-time
        function.  If the compile-time function can be told to compile itself
        into a temp area and executed, it will be. This allows
        compile-time functions to be used.  If there is an error, the 
        FUNCFAULT JBasic error is thrown, with the compile-time error of
        the runtime invocation stored as the fault parameter.
    
    7.  Improved detection and handling of constant argument lists for
        functions that compile themselves rather than having a runtime
        element.  For example, QUOTE("A") detects a constant string argument
        list and generates just the constant string.  A more complex example
        is SUM() which detects a constant argument string and executes the
        compiled code once in a temporary bytecode area to determine the
        constant value, which is all that is placed in the ultimate generated
        code.
    
    August 12, 2009
    ---------------
    1.  Remove legacy code that predated linked programs, where many branch
        operations (_JMP, _RET, _FOR) had two sections of code; one for linked
        and one for non-linked.  Removed a branch test in the execute loop
        for modest performance gain.
    
    2.  Fix bug where EXECUTE "stmt" didn't work in a program when the string
        statement can be compiled.
    
    3.  Add optimization for _EQ/_BRZ and similar sequences to remove the _BRx
        and allow _EQ and _NE to have an optional direct branch address for
        when the condition is true.

    August 20, 2009
    ---------------
    1.  Better parsing on INPUT statement with a list of values.  Allow comma 
        or semicolon to separate values. Allow empty value to be specified
        by successive commas or semicolons.  Also, fix minor syntax check 
        problems with compilation of ill-formed INPUT statements.
    
    2.  Fixed bug in recursion matching test for arrays that contained records.
    
    August 28, 2009
    ---------------
    1.  Minor optimizations to ByteCode, such that code streams with no ON
        statements don't incur the overhead of adding to the handler stack.
    
    2.  Optimization so that integers added-to or multiplied-by a variable 
        are converted to _ADDI or _MULTI regardless of the order of the
        operation.  That is, 3*X is treated the same as X*3, etc.
    
    3.  Don't bother running optimizers for streams less than 6 instructions,
        since they generally don't benefit.  This should pretty much ensure
        that any linked program is optimized, but some very simple statements
        (PRINT "Hi") won't be.
    
    September 6, 2009
    -----------------
    1.  More misc cleanup of the code; removing poor logic constructs and
        tightening up some operations such as how the SYS$CURRENT_PROGRAM
        is stored (should be a readonly variable, but wasn't), etc.
    
    2.  Fix bug in handling of looping pseudo-bytecodes like BRLOOP, DO, 
        and LOOP. This was causing bytecode concatenation problems, which
        showed up in statements like TIME.
    
    3.  Make the variable that holds the TIME data be hidden so it doesn't
        show up in SHOW SYMBOLS, etc. as well as being readonly.
    
    September 22, 2009
    ------------------
    1.  Fix bug where TRACE of a statement or program that gets an error can
        leave TRACE mode enabled.  Also, now TRACE with no command is the same
        as RUN of the current program with trace enabled.
 
    2.	Cleanup for statement stubs; using a verb with none of the 
        expected arguments was resulting is silly errors.  These are
        now largely corrected.
           
    September 27, 2009
    ------------------
    1.  A user is trying to port HP 2000 BASIC programs to JBasic.  There
        are quite a few interesting dialectic features of this version 
        of BASIC (also often called TimeShare Basic).  I'm going to cherry 
        pick a few of them to see if they are useful.  
        
        First up, adding MIN and MAX as numeric operators; i.e.
            
            X = 3.5 MIN 3.6
            
        results in X being assigned the value 3.5.  These operators
        really map into calls to the MIN and MAX functions, so both sides
        of the operator are effectively converted to doubles for the
        MIN or MAX test.

     2. Another problem found with array and record constant elements that
        resulted in values that weren't unique.  X=[1,2,3], followed by
        Y = X[2], would put a reference to X[2] in Y rather than a unique
        copy.  Subsequent changes to X[2] could result in Y changing value.
        Now, when any item is stored in a symbol, a recursive stamp of
        values with the fSymbol attribute is made.
     
     3. To debug #2 above, added _DEBUG 3 (dump a value), _DEBUG 4 (dump
        a value recursively), and _DEBUG 5 (dump a symbol) to support
        diagnosing object issues - the object class and hash value are
        printed to detect when a unique object versus a reference is 
        made.  Also added SHOW SYMBOL <name> which uses _DEBUG 5 to dump
        recursive data about a symbol.
        
        A SHOW SYMBOL of a native JBasic object shows the hash code for
        the Value object that contains it.  Using the same command on a
        Java object wrapper shows both the hash code of the wrapper and
        the underlying object.  Remember, X=Y creates a new Value wrapper
        for X but the underlying object is pointed to by both variables!
]CHANGES 2.8

The following changes were made to Release 2.8, following the release of
the 2.7 system to SourceForge on 5OCT09.

    October 6, 2009
    ---------------
    1.  Add URL() function that parses URL strings, and breaks out each
        of the primary components.  It also parses the query string if
        present and breaks it into keys and arrays of values as well.
    
    2.  You can change the password encryption "secret key" by setting
        the global variable SYS$PASSWORD_SALT to a string value of your
        choosing.  This must be done before the PASSWORD() function is
        first called or the user manager loads user data  The variable
        is deleted when it's value has been used to initialize the
        password encryption subsystem.  Note that if you change this
        value, then exising multi-user server data passwords will no
        longer work.
        
        It is the responsibility of the owner of the parent session to
        set this value in a fashion that meets your security requirements.
        If the salt is not provided, then an internal string is used.
     
     3. Updated internal doc on functions to describe a dozen or so
        functions that weren't accurate or even present in the HELP.
     
     4. Improved type checking for functions; a function that accepts
        a number (INTEGER or DOUBLE) can now more easily check for
        argument types.
     
     5. Allow optional 4th argument for REPLACE that includes a count
        of the number of instances that will be replaced.
     
     6. Add WHERE operator. The LHS value must be an array of records
        and the RHS is an expression. The expression is executed for
        each member of the array and if the result is a boolean true
        value, the array member is included in the result set.
        
        The array of records must be non-empty, and each element
        must have the same member schema.  For each array element,
        the members are stored as local variables for use by the 
        test expression.
        
        X = [ {ID: 1003, NAME:"Bob"}, {ID: 1053, NAME:"Dan"} ]
        Y = X WHERE( ID = 1053 )
        
        This results in Y containing [{ID: 1053, NAME:"Dan"}] because
        it is the only member of the array X that matches the test.  
        Note that the comparison expression references the record
        fields as local variables.  The expression can be any
        expression including calls to functions, etc. and need not
        necessarily reference the individual field members.  For 
        each row, a temporary variable _INDEX_ contains the
        current row number in the array, so exprssions can be created
        that do calculations based on the position in the array. 
        
        The WHERE operator is about 8x faster than one could write
        comparable JBasic inline code.
     
    October 10, 2009
    ----------------
    1.  Allow IN() operator to test for a member being in a RECORD. For
        example,
        
           X = URL("http://apple.com/store?id=1035&item=iPod")
           IF "ITEM" IN( X.QUERY ) THEN CALL CHECK_ITEM(X.QUERY.ITEM)
       
        In this case, a URL is parsed and the code needs to see if the
        query contained the name ITEM.  If so, a call is made using that
        data.  The IN() operation is true if the LHS string is the name
        of a member in the record on the RHS.  When a record is used on
        the RHS (as opposed to an array) then the LHS must be a string.
     
    2.  Fix a few bugs in LOCK USING() and UNLOCK USING() so that the
        data type must be a string or array of strings.  
        
    3.  Remove the previously-deprecated THREAD statement.  All the
        previous functions ([UN]LOCK, EXECUTE, etc.) are implemented as
        discrete statements on their own.
     
    4.  Remove unneeded SYS$THREADS global variable; the THREADS()
        function gives an accurate list of currently-visible threads.
     
    5.  Add CLEAR MESSAGE <name> command which can clear a name mapping.
        All language encodings of the given name are deleted.
     
    October 26, 2009
    ----------------
    1.  Create new subclass of Value for RecordStreamValue which is an
        array of homogenious records. 
     
    2.  Created JOIN( base, merge, "key") function that joins the base
        RecordStream with the merge RecordStream, matching records with
        the same value in the "key" member.
     
    3.  Allow SORT() to specify a RecordStreamValue and a string, and
        sorts the results based on the key field of records in each
        array element - if the first argument isn't a valid RecordStream
        (not all arrays with the same members, etc.) then it is sorted
        just as a normal array for SORT.
     
    4.  Started on optimizing RecordStream to always be an array of arrays
        with a separate key table so we don't pay the HashTable cost when
        manipulating them.

    October 31, 2009
    ----------------
    1.  Finished conversion to RecordStreamValue subclass, which implements
        an array of arrays.  The RecordStreamValue also contains a table of
        the column names and data types as metadata, that are created when
        the object is created.
    
    2.  Added TABLE statement to create RecordStreamValue data objects. Added
        support in JOIN, SORT, and WHERE to process RecordStreamValues.  The
        ADD operator allows adding new rows to the TABLE.
        
    3.  Implement TABLE data in XML() and XMLPARSE().  Because a PRINT of
        a TABLE results in a formatted output, you can't easily use it to
        store a TABLE in a file.  Use XML instead to store the TABLE and
        a subsequent parse will correctly reconstruct the metadata, etc.
        for the table.
    
    4.  Fix bugs such that TABLES can be updated using array notation; i.e.
        
            EMPDATA[3] = [100,"Bob", 7.25]
        
        will update row 3 of the table with the given array.  The data
        types are all coerced to the correct column types and stored in
        the table. Inserting into the table beyond the last row causes
        new empty (type-specific default values) to be inserted into the
        table.  Because of this, addition is preferred over array subscript
        notation because it always adds the row to the end.
    
    November 10, 2009
    -----------------
    1.  Allow INPUT ROW OF F or alternatively INPUT ROW(F) where F is an
        existing table. A row's worth of data is read from the input source
        (file or console) and added to the end of the table.  The table must
        already exist.  Data types are converted to the correct type as
        needed. If a string prompt is not given and input is from the
        console then a prompt is constructed showing the row member names.
    
    2.  Added _ROWPROMPT and _INPUTROW opcodes to support the INPUT of a
        table row.
    
    3.  Fix embarassingly obvious bug in handling of signs on INPUT of a
        row or a scalar numeric value.
    
    4.  Simplify the _THREAD opcode by factoring out CLEAR LOCK operation
        (moved to the _CLEAR opcode) and creating new _SLEEP opcode.
        
    December 3, 2009
    ----------------
    1.  Start on SOCKET programming in JBasic.  Supports character and
        line communication in both directions.
        
             OPEN SERVER SOCKET 6501 AS #1
        
        This opens a socket as a server.  The statement waits until a client
        connection is made to port 6501.  Because it waits, it should be run
        on a thread if multiple waits are to be permitted simultaneously.
        
             OPEN CLIENT SOCKET "localhost:6501" AS #2
        
        This opens a client socket connection on the given host and port
        number.  From here, PRINT and LINE INPUT statements can move records
        of data between the two connections.
        
        You can use EOF() on a SOCKET file to determine if the next read
        operation will block (i.e. is there already data to be read or not).
    
    2.  Added indirect file names with USING clause.  This is needed because
        a SERVER socket is used over and over for a multi-user server and
        we need unique file IDs for each one.
        
            X = "SOCKET"+UNIQUENUMBER()        // Or any unique string
            OPEN SERVER SOCKET 6501 USING(X)   // USING in place of AS
            
            PRINT #USING(X); "MESSAGE SENT TO SOCKET"
            CLOSE #USING(X)
            
    3.  Added CONSOLE statement which redirects the current thread's
        console to a given fileref.
        
            CONSOLE OUTPUT #3
            SHOW STATUS
            CONSOLE OUTPUT
        
        This sequence temporarily redirects console output to a given
        file ref, executes the SHOW STATUS command, and then resets the
        output back to the current default.  You can set OUTPUT or INPUT
        console modes, or omit the keyword and select both.  This requires
        FILE_IO privilege.
    
    4.  Simplified file classes, so you can generally use a JBasicFile
        everywhere, and an exception is thrown if the underlying file
        type isn't correct.  This allows a SOCKET to be used where a 
        FILE was previously only allowed, for example - needed to allow
        CONSOLE output redirection to a socket if needed for web serving,
        etc.
    
    5.  Modify the URL() function to allow the case of two arguments,
        where the first is the "context" URL and the second is the
        actual URL to parse.  The idea is that if you are a web server,
        you will get partial URLs as part of the GET protocol that you
        match against a context for your server to fill in missing data
        or to define root path info.
     
     6. Really simple example program $WEBSERVER added to Library to
        show how sockets might be used.  CALL $WEBSERVER AS THREAD
        will start the server and let you monitor JBasic from a web
        browser.
    
    January 16, 2010
    ----------------
    1.  Allow member addressing of a table to return an array containing
        all values in the column.  So for a TABLE FOO
        
            TABLE FOO AS INTEGER ID, STRING NAME
        
        The reference FOO.ID or FOO["ID"] will return an array containing
        the column of the table of all ID values, all of which are the 
        INTEGERS from the rows in the current sort order.
    
    2.  Allow SHOW ALL PROGRAMS to display all programs, even those that
        are normally hidden by virtue of having a leading "$" in the name.
    
    3.  Add CHAR(n) informat.  Note, the INFORMAT material needs to be
        documented and it is spotty at best at the moment.
    
    4.  XML(value, 2) will create an encoded XML value that isn't human
        readable with respect to the actual value. However, XMLPARSE()
        can still decode it.  This allows XML data to be stored with
        some security as long as the XML data isn't just reprocessed again
        with JBasic.
    
    5.  SAVE PROTECTED now uses encrypted XML with a private key.
    
    February 8, 2010
    ----------------
    1.  Implement ADD, SUBTRACT, MULTIPLY and DIVIDE statements for ease
        of reading by new programmers.  Also makes it easier to add a row
        to a table.
    
    2.  Users should be aware that post increment and decrement operations
        are done after the store is complete.  So
        
            ADD 3 TO A[B++]
        
        will increment B after the store of the sum is done. This means that
        multiple instances of increments will all be deferred, which can have
        unexpected effects.
        
            ADD 3 TO A[B++, B++]
            
        The current value of B is used for both dimensions of the array,
        and the value is then incremented twice.
        
    3.  Added SET [NO]NEW_FORMATTER command that lets you select between
        two different tokenizer strategies.  The NONEW_FORMATTER uses the
        previous historical behavior, which is to put a space between most
        but not all tokens. By contrast, the NEW_FORMATTER behavior is the
        opposite; spaces are only put in when really needed to be able to
        accurately re-parse the buffer, or in a very few cases to aid with
        readability.  The default is unchanged; NONEW_FORMATTER is the
        default while it is debugged and tested.
    
    February 13, 2010
    -----------------
    1.  Fix bug in use of program-only statements as subordinate clauses in
        FOR..DO and IF..THEN statements.  This prevented things like
        
            IF X = 0 THEN RETURN 0
        
        From compiling correctly.
    
    2.  Fixed problem where RETURN statement followed by an array expression
        was mis-intepreted as a "silent LET" when used as a subordinate
        statement clause as in the example above.
    
    3.  Fixed minor-but-annoying formatting problems with subordinate clauses
        when re-tokenization enabled.
    
    4.  Optimization when FOR..EACH is used on a single item.  This 
        simplifies the code generation for scans of large arrays; a 
        duplicate copy isn't created on the stack. Single scalar
        values will be converted to an array by the _FOREACH opcode.
    
    May 1, 2010
    -----------
    1.  Changed behavior of TRACE command, so it traces both the statement
        and the underlying bytecode.
    
    2.  Add SANDBOX keyword to EXECUTE statement, which executes the string
        expression in sandbox mode; i.e. no permissions.  This allows use
        via a web handler, etc. where arbitrary user statements must not
        be allowed.
        
        		EXECUTE SANDBOX CMD$ RETURNS X
        
        Will execute the command in CMD$ in sandbox mode, and set X to the
        return code state.
    
    June 1, 2010
    ------------
    1.  Add ability to select array elements as a list of members or as a
        boolean selector list.  For example,
        
           x = ["Tom", "Mary", "Sue", "Bob", "Donna", "Joe"]
           y = [1,2,4,5]
           z = [false, true, true, false, true, false]
           
           print x[y]
           print x[z]
       
        The first will output the array ["Tom", "Mary", "Bob", "Donna"] as
        the list of integers describes the indexes of the source array to
        select for the result of the expression.
       
        The second print statement outputs ["Mary", "Sue", "Donna"] because
        the array of boolean values is used as a selector to determine if a
        member is includes in the output result set or not.
       
       
    August 24, 2010
    ---------------
    1.  When a protected program is run with TRACE mode enabled, the WHERE
        subclause bytecode is no longer traced (bug-fix).  Removed the
        unhelpful message that tracing was suspended; it's not needed and
        is difficult to supress after the first instance.
    
    2.  Correct problem where DATA statement initialization did not occur
        in a protected program loaded from disk as XML.
    
    October 29, 2010
    ----------------
    1.  A few minor typos and similar spelling fixes in source code.
    
    2.  Allow SET X TO 3 as an alternative to LET X = 3, to improve program
        readability. [DOC]
    
    3.  Updates FILES verb to use more modern constructs for readability.
    
    November 15, 2010
    -----------------
    1.  Experimenting with string pooling in the optimizer.  When a _STRING
        occurs more than once in a program, it can be pooled using the new
        _STRPOOL option which stores it in a static vector for retrieval at
        runtime.  It's not clear to me that this is worth while yet or what
        conditions must exist for this to be beneficial to the memory map.
        The default is to leave this off, look in Optimizer.java for the
        static constant OPT_STRING_POOL to enable the feature if desired.
    
    November 29, 2010
    -----------------
    1.  The string pooling can be controlled with SET STRING_POOLING and
        SET NOSTRING_POOLING, or SET STRING_POOLING=n to set the threshold
        of strings to pool where zero is the same as NOSTRING_POOLING.
    
    2.  Fix bug where workspace names didn't work correctly on file systems
        with case-sensitive names. Thanks to Edgardo Ariel for the report.
    
    3.  Start on macro facility.  New system symbol table named "MACRO" can
        hold values used for substitution.  So LET FOO<MACRO> = "PRINT" will
        create a macro variable FOO that contains the string "PRINT".
       
        When any statement is first read (input from console or file) and
        contains text like <@foo@> including the macro quotation symbols,
        text is replaced with the bracketed expression.  All symbols are
        resolved using the macro table, but other expressions can be used.
       
        So <@FOO@> <@QUOTE(FOO)@> results in PRINT "PRINT" being replaced.
    
    4.  If you enable logging of debug messages (SET LOGGING=3), the MACRO
        facility will display macro source changes and also report any errors
        during macro resolution.  Also modified the loader so macro resolution
        works correctly from a text file.  This is the start on templates.
    
    5.  The actual macro "quote" characters are defined in SYS$MACRO_QUOTES
        which must be an array of two strings, containing the starting and
        ending marker strings.  The default is ["<@", "@>"].
    
    6.  Add MQUOTE() function that adds current SYS$MACRO_QUOTES quotes
        to a given string argument, since these cannot be expressed in 
        source text without invoking the substitution operator.
    
    7.  Added optimizations to _LEFT and _RIGHT for constant lengths, so
        they can be expressed using the integer operand of the opcode
        rather than being pulled from the stack.
    
    8.  Corrected a lingering problem with creating an array of arrays
        where the nested array values where not unique if the array was
        create as a set of constants.  
        
           A = [1,2]
           B = [A,{A:A}]
           A[2] = 22

        would result in a modification to B[1,2], which is incorrect.

    December 1, 2010
    ----------------
    1.  Add a new opcode _TYPECHK which can compare the types of two values
        or a value and a description of the values and determine if the types
        match.

    2.  Add capability to the SET command to do type checking for options, so
        that you can only SET MACRO= to an array that contains two strings.
        This uses the new _TYPECHK opcode.

    3.  The new opcode is a shell around a Utility class method that can be
        generally used for this purpose.  The string descriptor mode allows
        you to specify the data type(s) as INTEGER, BOOLEAN, STRING, or DOUBLE
        and use array and record syntax accordingly.  The special value ANY
        is also used to mean any type, simple or complex.  The special value
        NUMBER matches either a DOUBLE or an INTEGER.

    4.  Added a TYPECHK function which takes a value and a descriptor and 
        does the type check operation, and returns true or false.

    5.  Added a _PROTOTYPE ["string"] opcode that compiles the descriptor
        string operand (or top of stack) into a prototype object of the
        given type(s).

    6.  Added caching to the prototype compiler so each prototype is only
        compiled once, and subsequent use of the same descriptor string
        just fetches the previous value.

    7.  Modified TYPECHK() function to compile directly to _PROTOTYPE and
        _TYPECHK functions.  Added TYPES test.

    8.  Added help for TYPECHK() function.  Added optimizations to collapse
        _PROTOTYPE and _TYPECHK operations when constant descriptors used.
    
    9.  Allow TIME command to accept integer constant count which generates
        code to run test statement multiple times and average result.
]CHANGES 2.9

The following changes were made to Release 2.9, following the release of
the 2.8 system to SourceForge on 8DEC10.

 December 10, 2010
 -----------------
 1.  Add missing HELP entries for SHELL and explain that QUIT can be
     used to exit a shell as well as JBasic.
 
 2.  Allow SYSTEM command to accept an array of strings as the argument,
     or a comma-separated list of strings and an implicit array is 
     created.  When an array is used (as opposed to a single string)
     then the first element must be the command and each additional
     string must be the arguments to the command.  If the single string
     is used, then blanks are used to break the string into command
     and arguments. Use the array form when any argument has a blank.
 
 3.  Ditto for the PIPE file type, which can now accept an array of
     strings as the pipe name which are construed to be the command
     and it's arguments.  Note that the OPEN PIPE command does not
     permit comma-separated name parts; you must use array syntax
     or create an array, as in  OPEN PIPE ["ls", "-l", FN] AS #1
 
 4.  Correct a problem where SYSTEM and PIPE commands didn't work
     properly on Windows 7 systems.

 December 15, 2010
 -----------------
 1.  Better synchronization with the listener threads that capture
     output and error streams from SYSTEM subprocesses, so we don't
     exit from the syncronous function prematurely while the threads
     are still flushing data.
 
 January 1, 2011
 ---------------
 1.  Change format of SHOW FILES command; rather than just dumping
     out the file ID record, format it usefully. This is particularly
     useful when the record contains FIELD or QUERY members that would
     make the output difficult to read.
 
 2.  Update copyright notices for 2011.
 
 3.  Catch invalid use of reserved console name "%TERMINAL%" for
     file modes other than INPUT and OUTPUT.  Fix problem where all
     files opened to this type were incorrectly marked as system
     files.
 
 January 5, 2011
 ---------------
 1.  Add _SETSCOPE opcode that sets the symbol table scope rules
     for the current execution context.  This can include making
     the table independant of scope, connected only to GLOBAL or
     ROOT scope, or connected to the original parent, grandparent,
     etc.
 
 2.  Use the new opcode to arrange for VERBs to always have 
     LOCAL_SYMBOLS which means the local table is independant
     of the rest of the user-symbols, and only connects to the
     GLOBAL table for access to system data and constants.  This
     prevents verbs from being able to unintentionally (or
     intentionally) modify the caller's symbols except through
     explicit means.

 3.  Added new PRIVATE and SCOPED as DEFINE() pragma values 
     for programs and verbs.  This lets the user set the 
     symbol scope explicitly for a given program if
     needed.  For example, a verb that needed to access the
     caller's local symbol table can override the normal 
     isolation of verb symbol tables by specifying SCOPED.
     By comparison, a program that needs to run in isolation
     from it's caller can use PRIVATE.
 
 4.  Reclaimed the RECORD verb to be used to declare an empty
     RECORD value, from it's previous function as a deprecated
     form of the FIELD statement. 
 
 5.  Allow a PROGRAM & VERB statement to use DEFINE or PRAGMA
     interchangeably to declare entry characteristics.
 
 6.  Added new PRAGMA(STATIC) and PRAGMA(DYNAMIC) that set a 
     range of values for STATIC_TYPES, LOCAL_SCOPE, and
     STATIC_ALLOCATION such that all variables must be declared
     of a given type and maintain that type for their lifetime.
     PRAGMA(DYNAMIC) sets the traditional JBasic settings for
     completely dynamic variable creation and data typing.
 
 7.  Added new values STATIC_ALLOCATION and DYNAMIC_ALLOCATION
     to the PRAGMA list that determine if a variable must be
     declared with type or DIM statement before first use.
     
 8.  Corrected bug in ARRAY statement where it would not let
     an ARRAY be initialized with an array value correctly.
     
 9.  Allow STATIC and DYNAMIC to be separate terms in the program
     definition (as opposed to only allowed in PRAGMA/DEFINE).
     Allow RETURNS declartion to put name in parenthesis if
     desired.  Allow any declaration terms in any order, so
     
         PROGRAM FOO STATIC RETURNS(INTEGER)
         PROGRAM FOO RETURNS INTEGER DEFINE(STATIC)
     
     are interchangeable stateemnt definitions.

10.  Fix bug where NEW followed by a program name and additional
     program qualifiers didn't parse correctly if there were no
     program arguments declared.

11.  Fix bug where FOR statement didn't honor STATIC allocation rules.

12.  If a program is declared STATIC, then it's symbol table isn't
     visible to programs it calls directly or indirectly; that is,
     FOO calls BAR, and BAR cannot create variables in FOO's table
     when FOO is declared STATIC.

13.  Change SET ROOT_USER backdoor to use one-way hash value to enable
     root user mode.

 January 13, 2011
 ----------------
 1.  Add CLOSE PIPE command.  This lets the program close the write 
     side of a pipe file, but leave the read side open to read any 
     remaining output.  This is needed for a command that reads stdin
     and writes stdout and requires that an EOF be read on stdin before 
     it completes, such as the "wc" command. 
 
 2.  Allow arbitrary Unicode character escapes using \uHHHH where HHHH
     must be a four-digit hexadecimal value.  For example, \u00f1 will
     produce the Spanish language n with a tilde ("enyay").  This allows
     arbitrary characters to be encoded in quoted string, so the messages
     in the Messages.jbasic file can be written in a native language and
     not get garbled by translation and copying of the file through 
     different encodings.
 
 3.  The STRING() function, when given a string, will no process any
     escapes in the string.  So A = STRING("\u0022") will result in the
     value of a double-quote being stored in the variable A.
 
 4.  Fix bug where record constant temporary storage did not work for 
     programs with STATIC variable declaration when SET POOLING was 
     enabled.
 
 5.  Fix bug where multiple instances of the same constant record were 
     not handled correctly when SET POOLING enabled.  Fix bug where 
     FOR..EACH with a pooled constant incorrectly changed the constant
     type to an array.
 
 6.  Fix bug where ARRAY constants were not created properly with 
     SET POOLING; the linker was not using _DCLVAR with the correct 
     type.

January 27, 2011
----------------
 1.  Fix bug where GOTO USING() did not correctly handle numeric values
     representing line numbers. Added new unit test for GOTO handling.

 2.  Changed location of message definitions. When JBasic starts, it
     attempts to locate Messages.xml which contains the language-specific
     definitions of each message code in standard XML format.  _DEFMSG 3
     will read this file, and _DEFMSG 4 will save it as needed, with the
     string paramter containing the file name.

 3.  SAVE MESSAGES "file.xml" will write the current message database
     to the named file.  LOAD MESSAGES "file.xml" will append any message
     definitions in the named file to the current session.  Omitting the
     filename on LOAD assumes the default file name of "Messages.xml".
     CLEAR MESSAGES will delete the active message database in memory.
 
 4.  Make it easier for program-local messages to be cleared away when
     not needed.  By convention, create program-local messages with a
     prefix ending in a "$" character.  For example, the TYPE verb
     creates messages with TYPE$ prefix in the code name. These can
     then be deleted from the message database on a successful
     execution with CLEAR MESSAGE TYPE$.  The trailing "$" acts as
     a wild-card to delete all such messages.  Alternatively, use
     CLEAR MESSAGE INV* where the trailing asterisk deletes all
     messages starting with INV. 
  
  5. Fix bug where SERVER QUIT "user" threw and exception if the 
     server was not running. Also, better handling of message
     formatting when the message databse is empty.
  
  6. Add ability to set permissions in a non-remote sessions.  This
     makes it easier to write and test programs that have permissions
     sensitivity; just use SET PERMISSION=[no]permission to set or
     clear the permission.  This requires ADMIN_USER in a remote
     sessions but can be done by any program in the main session.
     Use SHOW PERMISSION to see the current list.
  
  
  February 8, 2011
  ----------------
  
  1. Externalize permissions names in PermissionNames.xml which is
     in the jar file.  This is loaded by SHOW PERMISSIONS and then
     the library program $SHOWPERMISSIONS is run to display the
     permission info.  This makes changing the format of this
     easier, and also means loading the permission names file can
     be done even when permissions themselves would prevent it.
  
  2. Allow SET PERMISSION=(permission-list) to accept a list of
     permission keywords, including ALL and NONE to add or remove
     all permissions.

  3. Upgrade message loading to use the SYS$PATH array of prefix
     locations to search for messages file(s).
  
 February 17, 2011
 -----------------
  1. Fix bug in EXECUTE statement that cause compiler hang for
     certain ill-formed statements.
     
  2. Fix bug where EXECUTE SANDBOX didn't work for command-line
     user because permissions weren't changed.  Now the command
     temporarily strips the session of all privileges.  You can
     specify specific privileges that are granted to the command
     being executed with EXECUTE SANDBOX(perm[,perm...]), such
     that the following command is executed with only the named
     permissions. For example,
     
         EXECUTE SANDBOX(DIR_IO) "FILES"
     
     Runs the FILES command with only the DIR_IO permission set.
     The permission list does not accept "ALL" or the "NO" prefix;
     all permission names must be given explicitly.
     
  3. Fix bug in array subtraction; scalar values did not correctly
     get subtracted from arrays (which deletes the matching item
     if there is one).
     
  4. Add constant fold optimizations for MULT, MULTI, ADD, and 
     ADDI of heterogeneous INTEGER or DOUBLE constants.  Add
     optimizations for storage declaration to remove unneeded
     initializers. Added optimization for printing string
     constants via _OUT or _OUTNL.
  
  Febuary 22, 2011
  ----------------
  1. Implement pattern-matching optimizer.  This uses a totally
     data-driven map of patterns to search for, and replacment
     operations to change the instruction pattern to.  This
     allows optimizations to be added that are relatively simple
     without adding new code.  The optimization dictionary is
     found in !OptDict.xml.
  
  2. Move basic patterns out of the explicit optimizer
     and into the data-driven optimizer.  Most of the optimizer
     operations can be expressed as patterns, except for the
     complex branch optimizations.
  
  3. Added helper functions _SYS 12 to add a Value on the stack
     (a record with PATTERN and REPLACE arrays) to the optimization
     list, and _SYS 13 "file" which writes the current dictionary
     to an xml file.  Added SET [NO]OPTDEBUG which displays debug
     data as optimizations are performed.
  
  4. Fix bugs in conditional branch optimizations and in handling
     of _INCR to non-integer values.
  
  5. Enable pattern matching optimizations inside code blocks such as
     _WHERE and _DATA groups.
  
  6. Fix bug where Pattern Matching Optimizer was optimizing pattern
     sequences that contained targets of branches and could not be
     moved/changed.
  
  7. Set TRACE back to trace statements by default; too many use 
     cases don't want or need the bytecode. You can enable bytecode
     tracing with TRACE(BYTECODE) ...command... if needed.
  
  8. Move constant folding to Pattern Matching Optimizer.  The non-PMO
     work is now limited to branch resolution issues and constant pooling
     that are beyond the scope of the peephole process.  Also, added
     better error handling for invalid OptDict.xml entries.
    

  March 12, 2011
  --------------
  1. Tracking optimizations.  Added a name= attribute to each pattern set
     in the XML file.  Allow _SYS 14 to dump the match counts for each
     pattern, and _SYS 15 to re-zero the match counts.  This lets you
     see what optimizations are having what effect on the code for a 
     given program by zeroing the counters and loading the file.
  
  2. Added SHOW OPTIMIZER to display the optimization pattern counts, 
     and CLEAR OPTIMIZER to zero the counts out. Add SHOW OPTIMIZER
     followed by an optimizer name to display the pattern.  [DOC]
     
  March 28, 2011
  --------------
  1. Fix bug in optimizer that prevented _STMT or _NOOP as a target 
     of a branch from being optimized away if called for in a pattern.
  
  2. Added dead code removal, so that optimizations for constant values
     in branches or GOTO followed by unreferenced code can be deleted.
     This is only done within a statement (not between statements) since
     GOTO USING() could branch to any arbitrary statement.  This is 
     enabled by default, SET [NO]OPTDEADCODE controls it.
  
  3. The SET [NO]OPTASM flag controls whether code that is assembled
     using ASM or ASM USING() is optimized. The default is NOOPTASM.
  
  4. Minor restructuing of optimizer options (OPTPOOL and OPTSTRUCTS)
     so they have OPT as the name prefix and are grouped together in
     SHOW command output.
  
  April 3, 2011
  -------------
  1. Fix bug when subtracting non-constant value from an array.
  
  2. Fix missing optimization for formatted integer and double 
     constants output to a file other than the console.
     
  3. Additional PMO optimizations for simplifying branches in 
     IF-THEN-ELSE statements and deleting empty statements when
     optimizing linked bytecode streams.
  
  4. Minor refactoring of PatternOptimizer class to make the source
     more managable.
  
  5. Added transitive optimizations for integer addition or 
     multiplication of scalar variables.
  
  6. Fix slightly obscure problem with coercing to a denormalized
     or formatting string resulting in a non-string type.
  
  April 21, 2011
  --------------
  1.  Minimal support for native SQL. Use the SQL statement followed
      by a valid SQL statement.
      
  2.  Support SQL SELECT with WHERE and ORDER BY clauses which extracts
      columns and rows from an existing TABLE data type and prints it.
  
  3.  Support CREATE TABLE... AS SELECT... which extracts data from an
      existing table and populates a new TABLE with the result
  
  4.  Support CREATE TABLE... LIKE SELECT... which creates an empty
      table with metadata patterned off of the result of the SELECT

  5.  Support SQL() function that accepts a string SQL statement and
      executes it, returning the result.  Really only works with
      SELECT statements. 
  
  6.  Allow ORDER BY clause in SQL to support multiple keys.  This is
      also now supported by the SORT() function when given a TABLE
      and one or more string arguments that are column names.
  
  April 29, 2011
  --------------
  1.  Continued support for SQL statements.  Add INSERT...VALUES()
      statement support to add a single row to an existing table. 
      
  2.  Allow SQL statements to be directly entered as JBasic statements
      without the SQL prefix when the SET SQL command is enabled (this
      is the default).  You can turn off accepting of statements
      directly with SET NOSQL.
  
  3.  Clean up messages for MockSQL class.
  
  4.  Add CREATE TABLE with explicit DDL specification.  For example,
  
         CREATE TABLE FAMILY(NAME CHAR, AGE INTEGER)
  
      Creates a new table FAMILY with a STRING and INTEGER field.
  
  May 9, 2011
  -----------
  1.  Fix bugs that prevented a statement from being able to
      simultaneously compile some versions of the statement
      and still be able to interpret others without causing
      the linker to freak out.
      
  2.  Modified _WHERE so when a zero-count WHERE clause is
      found, it assumes no rows are selected.  This is the
      same kind of optimization as adding WHERE 0=1 in a SQL
      statement.

  3.  Convert SQL CREATE and SQL SELECT statements into compilable
      statements generating direct inline code.  In these cases
      there is no separate prepare(), execute(), and fetch()
      calls if the statement can be completely generated.  Only
      in cases where it must be intepreted will it used the
      conventional JDBC-ish calls.
  
  4.  Allow SELECT COUNT()... to return a single value which
      is a row count. This also means that the SQL() function
      may return a scalar value rather than a table; the
      calling code must check the TYPE() of the result if
      needed.
  
  5.  Fix bug where LENGTH() didn't return the row count
      for TABLES properly.  Fix bug where SQL() didn't
      correctly handle creating new output tables when
      needed.
  
  6.  Convert INSERT SQL statement into generated code, and
      support INSERT INTO.. SELECT... to load the contents
      of a query into a table.  Also fix the _ADD operator
      to correctly handle adding an entire table to another
      table.

  7.  Added SELECT COUNT( DISTINCT ...)... to count the 
      number of unique rows in a result set, and SELECT 
      DISTINCT to return the unique rows of a result set. 
      The result set can identify one or more variables
      or use the * convention for all variables.
  
  8.  Massive performance improvement in SQL INSERT
      command.  This is the preferred way to add rows
      to a table (10x faster) than using the add or
      concat operators.
 
  May 14, 2011
  ------------
  1.  Add DROP TABLE statement to SQL grammar. This deletes
      a TABLE from memory.
  
  2.  Use SET SQLDISASM to have the SQL() function display
      the generated code it executes.
  
  3.  Generate code to validate the TABLE given in SELECT
      or DROP statements.  Fixed bug in generation of WHERE
      clause expressions.
  
  4.  Implement basic JOIN <table> ON <expression> where the
      expression can reference elements of either table as
      record members.
      
      SELECT * FROM T1 JOIN T2 ON T1.ID = 100 AND T2.ID < 5
      
      The ON clause reference column names from either table.
      IF the column name was unique to a table you do not
      need to specify the table name.
  
  5.  Allow WHERE clause on each member of a JOIN so filtering
      can be done before the join when practical.
  
  May 25, 2011
  ------------
  1.  Support functions as source of SELECT clauses, where the
      function must return a TABLE value type.  
      
          SELECT AGE, NAME FROM FAMILY() ORDER BY AGE
      
      works when FAMILY() is a function that returns a table. This
      could be used to wrapper a DATABASE file, for example.

  2.  Support record format for table names.  This allows us to
      support the idea of a SQL catalog, which is really a record
      that contains named tables.
      
          SELECT * FROM EMP.NAMES
          
      uses the table NAMES that is a member of the EMP record.
      
  3.  Support reading from actual JDBC databases as part of
      the "native" SQL processing.  So
      
        CREATE TABLE OLD AS SELECT NAME FROM FB.FAMILY
            WHERE AGE > 50 ORDER BY AGE
      
      Creates a TABLE variable that is constructed by reading
      the database file FB table named FAMILY.  The WHERE
      clause is passed to the database to filter out the 
      rows we will need, and the sort is done locally on the
      resulting OLD table.
  
  4.  Support INSERT INTO CATALOG.TABLE... syntax to write
      rows directly into a catalog (record) containing tables.
      Note that this is not supported for JDBC tables, only
      native tables.
  
  5.  Support CREATE TABLE CATALOG.TABLE... syntax to create
      a new table as a member of a catalog, where CATALOG is
      a record containing tables.  This is not supported for
      JDBC catalogs, only native tables.

  June 13, 2011
  -------------
  1.  Add DROP TABLE support for catalog format (CAT.TABLE)
      for native tables.
  
  2.  Allow CLEAR R.M format to clear a member from a record.
      Also, clean up internal code references to _CLEAR type.
      [DOC]
      
  3.  Require a catalog to be created with CREATE CATALOG 
      followed by the catalog name.  Catalogs are records with
      special attributes. PRINT of a catalog shows the tables
      and their record format. [DOC]
  
  June 21, 2011
  -------------
  1.  Fix bug in PMO where adding two double constants didn't
      work correctly.
  
  2.  Fix bug in PMO where backwards branch from within the
      optimization to addresses before the optimizatoin were
      incorrectly offset as if they were forward branches.

  3.  Allow any source specification in a SELECT statement to
      be a nested SELECT statement.  Enclose the sub-SELECT
      in parentheses if needed to make subclauses unambiguous.
  
  4.  Get rid of SQL prefix on SQL statements; you can now just
      use INSERT, CREATE, DROP, and SELECT as standard verbs.
  
  5.  Allow a SELECT statement to be a term in an expression,
      such as  LET N = SELECT COUNT(DISTINCT AGE) FROM FAMILY
      where the result may be a scalar or a table.  The SELECT
      statement may need to be in parentheses to make any
      trailing part of the statement like a WHERE clause be
      unambiguious. [DOC]
      
      
  June 30, 2011
  -------------
  1.  Fix user-reported bug where NEW command didn't correctly
      detect incorrect syntax for specifying program name.

  2.  Fix user-reported bug where PRAGMA operations were not
      parsed correctly when there was an unexpected keyword or
      other syntax error; the compiler went into an infinite 
      loop instead. 

  3.  Detect unclosed quotes on a source line when at the end of
      the statement
  
  November 17, 2011
  -----------------
  1.  Store data catalogs in the Root symbol table so they are
      visible to all users.
  
  2.  Added SAVE CATALOG name [AS "file"] statement to save
      catalogs to disk as XML data.

  3.  Added LOAD CATALOG name FROM "file" to reload a catalog
      stored to disk with SAVE CATALOG.
  
  4.  If a catalog file name is not given in a SAVE or LOAD
      command, assume the name followed by "_catalog.xml"
      as the default name.
  
  5.  Allow CREATE CATALOG name to include optional AS "name"
      clause that sets the file name for the catalog.
  
  6.  Maintain a "Dirty" flag on a table that shows if a member
      of a catalog has been changed since the last SAVE CATALOG.
  
  November 27, 2011
  -----------------
  1.  QUIT will now automatically save catalogs that have a name,
      are dirty, and have the __CATALOG_AUTOSAVE flag set to true.
  
  2.  CREATE CATALOG <name> AS "<filename>" sets the AUTOSAVE flag.
      Also, CREATE CATALOG <name> AUTOSAVE sets the flag and assigns
      a default name.
  
  January 4, 2012
  ---------------
  1.  Allow LOAD IF CATALOG <name> to conditionally load a catalog
      only if it exists.  IF there is no such stored catalog, then
      no error occurs.  Remove if the IF to signal an error if the
      catalog is not found.
      
  2.  Fix bug where SYS$FUNCTION_MAP wasn't being created as an array,
      preventing legacy function name mapping from occurring; i.e.
      TRM$() being the same as TRIM().
  
  January 24, 2012
  ----------------
  1.  Add DECIMAL data type.  DECIMAL statement declares a variable,
      and integer constants that are too big for an INTEGER are
      stored in DECIMAL. 
  2.  Add scalar math (add, subtrace, multiply, and divide) and boolean
      operations for DECIMAL values.  Note that divide _can_ throw an
      error if the result is impossible to represent accurately.
  3.  DECIMAL(n) sets the scale (digits after the decimal point) for
      a DECIMAL value representing a fractional value.  IF no scale
      is given, 0 for integer value is assumed.
  4.  Use of the DECIMAL() function with a numeric value casts the
      number to a decimal.  Optional second argument is the scale.
      Use of DECIMAL() with a string does radix conversion as before.
  
  February 3, 2012
  ----------------
  1.  Change default rounding behavior for DECIMAL data types to
      ROUND_HALF_UP from ROUND_UNNECESSARY, preventing throwing
      exceptions on divide operations.
  
  2.  Add documentation on DECIMAL statement and DECIMAL function
      for creating numeric values.
  
  3.  Fix bug in convertion of double values to DECIMAL; the
      default is to use whatever scale is needed to represent
      the double as accurately as it is printed.  Add a unit
      test DECIMAL1 to cover regression tests for this type.
  
  4.  Modify TYPE() function to return scale as part of the
      type name when it is non-zero.
      
  June 4, 2012
  ------------
  1.  Fixes to the way SERVER initialization occurs and how to boot
      strap a system.  Extend SERVER SETUP command to create a
      default ADMIN and GUEST account if there are no user names
      defined.  Also, allow a string parameter to SERVER SETUP that
      will set the ADMIN user's password, to unjam a broken user
      setting.
      
  2.  Fix problems with accounts with no password, so they are
      correctly handled (no Password: prompt) and also handled
      correctly in the save JBasic-users.xml file.

  August 1, 2012
  --------------
  1.  Add SET [NO]FUNCTIONERRORS setting.  The default is off.
      When off, a function returns an empty result when practical
      for a runtime error.  For example, FILES() when given a
      non-existant path will return an empty array.  When on,
      the function signals an error that will stop a running
      program unless an ON ERROR statement catches it.
  
  2.  Fixed an NPE error in FILES() function when a bad path
      was given.

  September 16, 2012
  ------------------
  1.  Add GETBITS( buffer, bit-pos, bit-len) to extract an
      integer value from a buffer given a zero-based bit
      position and a bit-length.  It is an error if the
      position is outside the buffer or the length is <1
      or >32.
  
  2.  Add SETBITS( buffer, value, bit-pos, bit-len) to
      set an integer value into a buffer given a zero-based
      bit position and length.  The result of the function
      is the same buffer with the bits updated.
  
  3.  Allow SETBITS to use an arbitrary data type; if it is
      integer then a variable-width integer is written.  If it
      is STRING or DOUBLE then the full string or a double are
      written, at the given bit position (regardless of alignment).
  
  4.  Allow GETBITS to have an optional fourth parameter that
      defines the type.  If omitted, then "INTEGER" is assumed.
      This can be "INTEGER", "STRING", or "DOUBLE" to define the
      type of the value to fetch from the buffer.  Strings must
      be multiples of 8-bits long, and doubles must always be
      64-bits long.
  
  5.  Add ability to specify a BITFIELD() in a FIELD statement
      so a record can be read or written that is based on packed
      integer data.
  
  6.  Fix a number of bugs with method calls to native objects
      that should return results that map to JBasic native types.
      In particular, collections and sets should become ARRAYs,
      and HashMaps that are conforming should become RECORDs.
      This lets a HashMap be directly called and return results
      that can be used directly within JBasic.
  
  
  October 6, 2012
  ---------------
  1.  Add TEST$FILE15 for BITFIELD() in a FIELD statement.
  
  2.  Allow GETBITS() and SETBITS() to have an integer value
      as the buffer parameter; this results in changing bits
      within the 32-bit integer value.
  
  3.  Add TEST$FUNCTIONS6 to test bit operations.
  
  
  October 17, 2012
  ----------------
  1.  Add ability to access "fsm://" files from standard INPUT
      files. Supports line input and value input operations.
  
  2.  Add ability to create "FSM" files from standard OUTPUT
      files for any formatted output.
  
  3.  Support FILETYPE() and FILETYPES() functions for FSM
      URL syntax.  Support FILES verb for FSM URL syntax.
  
  4.  Support FSM files in KILL "name" and KILL #n modes.
  
  October 22, 2012
  ----------------
  1.  Fix bug in read-ahead buffer handling introduced by changes
      to JBFInput for FSM file types.
  
  2.  Support FILES() function with FSM URL.
  
  March 2, 2013
  -------------
  1.  Allow virtual mount points with FSM files.  A virtual mount
      point is created with
      
         SET FSM_MOUNT=["/bigdata", "fsm://asdgrd01/"]
         
      In this case, opening a file located in the "/bigdata" path
      would be translated to a call to the FSM servers defined in the
      URL in the second array element, as in
      
         OPEN INPUT FILE "/bigdata/foo.dat" AS #1
      
      which would open the file "foo.dat" on the FSM server.  If the
      SET FSM_MOUNT command is given with an array containing only 
      one value, then that mount point is deleted. [DOC]

  2.  Add MOUNTS() function which returns array of arrays, each of
      which contains a mount point mapping to an FSM URL as strings.
      [DOC]
  
  May 29, 2013
  ------------
  1.  Allow a list of assignment targets when the value being assigne
      is an array.  In simplest form,
      
         LET A, B = ["TOM", "MARY"]
      
      This assigns "TOM" to the variable A, and "MARY" to variable B.
      This is most useful, however, when a function is intended to
      return more than one value.  This can be done by returning an
      array, but it requires that the caller decompose the array
      elements.  Compound assignment allows each function result to
      be returned in a single variable. [DOC]
      
      Consider a function that returns the three components of a file
      name as an array:
      
         FUNCTION FPARSE( FILENAME )
         FP = FILEPARSE(FILENAME)
         RETURN [FP.PATH, FP.NAME, FP.EXTENSION]
         END
         
         LET P, N, E = FPARSE( "/here/file.dat")
         
      This example puts the path in P, the name in N, and the
      file extension in E in a single assignment statement.
      
      If fewer targets are given than are in the array, there is no
      error.  If more targets are given than are in the array, the
      remaining targets are set to NaN.  It is an error if the right
      side of the assignment is not an array type.
      
   2. Allow a list of values in a RETURN statement.  When more than one
      value is given, they are put into an array.  This way, a caller
      who does not use the compound assignment will still get a value
      single value (the array).  A caller using the compound assignment
      can put the values into results as desired. [DOC]
      
         function fparse( filename )
         fp = fileparse(filename)
         return fp.path, fp.name, fp.extension

September 9, 2013
-----------------
  1. Each session maintains an event queue; a list of strings desribing
     events and when they happened (using the millisecond clock).  The
     session startup tracks major events (library and function load,
     message file parsing, etc.) for each session (threads and user
     logins).
  
  2. The SHOW EVENTS command display the event queue for the session.
     SHOW ALL EVENTS shows all login sessions and sub-threads.  The
     CLEAR EVENTS command erases the list for the current session.
     [DOC]
  
  3. The EVENT command can add a new user event; it accepts an
     expression as the argument and converts whatever it is to a
     string and adds to the event queue. [DOC]
     
  4. The EVENTS() function will return an array of records with the
     event data:
     
       CLASS      String containing "SYSTEM", "MAIN", or "USER"
       NAME       String with the event name/description
       DURATION   Milliseconds since the previous event was stored
       TIME       Double containing the timestamp of the event.
    
    For example, PRINT DAT(EVENTS()[1].TIME) prints the timestamp
    of the first event, formatted as a date. [DOC]

January 18, 2014
----------------
  1. Allow SHOW PERMISSIONS and SET PERMISSIONS for any user even if
     they do not have ADMIN_USER.  The available permissions set is
     always constrained by the mask so there is no chance of elevating
     permissions illegally.  Note that SET PERMISSION=MASK will set the
     mask to the current permissions, which can be used to downgrade
     but never upgrade a permission mask.
  
  2. SERVER SETUP will generate a password for the ADMIN account if
     creating the initial ADMIN and GUEST accounts if one is not 
     given, and this is printed to the console log.
   
  3. The PASSWORD() function will generate a password if passed no
     arguments. If passed an integer it will generate a password
     containing that many words.
     
]CHANGES ROADMAP

    This section documents future plans.  These don't constitute 
    commitments but are the current development directions.  Think 
    of this as a long-term "to-do" list.
        
    1.  Need to try to handle keyboard interrupt from remote users;
        a user should be able to hit control-C to generate an 
        INTERRUPT signal.
    
    2.  There is a fundamental architectural issue with threads... not
        all the required execution context is separated from the
        bytecode.  We need to have a running program under a JBasicThread
        have a program state that is not stored in the bytecode, so more
        than one thread can execute the same bytecode stream at the same
        time.
        
 

 
..end of file
